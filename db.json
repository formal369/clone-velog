{
  "posts": [
    {
      "id": "d70f140c-62ea-4461-b19b-59d307b29cf4",
      "title": "깡통 탈출 프로젝트 #1 - MockMvc와 random port",
      "released_at": "2023-03-08T14:30:31.030Z",
      "updated_at": "2023-03-22T01:51:15.957Z",
      "tags": [
        "깡통 탈출 프로젝트"
      ],
      "body": "# 테스트 메서드에 @Transactional 좋다 vs 안좋다\n업무와 관련하여 테스트 코드에 대해 이야기를 나누던 중, 동료 분이 테스트 메서드에 `@Transactional` 어노테이션을 붙이는건 좋지 않을 수 있다며 [블로그 링크](https://dev.to/henrykeys/don-t-use-transactional-in-tests-40eb)를 하나 보내주셨다. 요약하자면, `@Transactional` 어노테이션이 붙은 테스트는 실패해야함에도 거짓된 성공을 할 수 있고, 데이터가 DB에 저장되지 않기 때문에 DB 문제를 알아내기 어렵다는 등의 이유로 좋지 않다는 내용이었다.\n\n\n마침 이와 관련해서 [토비님이 인프런에서 답변하신 글](https://www.inflearn.com/questions/792383/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-transactional-%EC%82%AC%EC%9A%A9%EC%97%90-%EB%8C%80%ED%95%B4-%EC%A7%88%EB%AC%B8%EC%9D%B4-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4)을 최근에 보았기에 다른 의견을 드렸다. 토비님은 테스트 메서드에 `@Transactional`을 쓰기를 적극 권장하신다고 한다. 이에 대해 꽤 길고 상세하게 적어주셨는데, 내가 요약하기엔 너무 어려운 내용이라 한번 직접 읽어보시길 바란다. \n\n슬랙에서 우리의 대화를 보시던 팀장님도 의견을 곁들어 주셨다. 그런데... 스레드가 길어질수록 점점 정신이 혼미해졌다.\n\n# 무슨 소리시죠...?\n모르는 소리에 모르는 소리가 쌓이고 또 모르는 소리가 덧붙여지고... 토비님의 인프런 글부터 시작해서 슬랙 대화까지 내 인지능력은 서서히 늪으로 빨려 들어갔다... 이런 점이 어렵다. 모르는게 너무 많아 도대체 뭐부터 알아야할지 막막해진다는 점이다. 막막할 땐 제일 만만한 것부터 공략해야 한다. 슬랙 대화에서 MockMvc와 random port에 대한 언급이 나왔다. 그나마 쉬워보이는 MockMvc와 random port에 대해 알아보자.\n\n# MockMvc란\nMockMvc는 Spring MVC 테스트를 지원하는 스프링의 클래스이다. 모든 웹 애플리케이션 빈을 캡슐화하여 테스트에 사용할 수 있도록 한다. 다음과 같이 사용할 수 있다.\n```java\nprivate MockMvc mockMvc;\n@BeforeEach\npublic void setup() throws Exception {\n    this.mockMvc = MockMvcBuilders\n    \t\t\t\t.webAppContextSetup(this.webApplicationContext)\n          \t\t    .build();\n}\n\n@Test\npublic void givenHomePageURI_whenMockMVC_thenReturnsIndexJSPViewName() {\n    this.mockMvc.perform(get(\"/homePage\"))\n    \t.andDo(print())\n        .andExpect(view().name(\"index\"));\n}\n```\n`perform()` 메서드는 GET 요청 메서드를 호출하고 `ResultActions`를 반환한다. 이를 사용하여 응답(response), 응답의 내용, HTTP status, header에 대한 기대값을 테스트할 수 있다. `andDo(print())`는 요청과 응답을 출력할 것이다. 에러가 발생할 경우 자세한 내용을 확인하는 데 유용하다. `andExpect()`는 전달된 인자를 예상(expect)한다. 이 경우에는 `MockMvcResultMatchers.view()`를 통해 \"index\"가 반환될 것으로 예상하고 있다.\n\nMockMvc에는 몇가지 제한 사항이 있다. MockMvc 클래스는 내부적으로 DispatcherServlet의 서브 클래스인 TestDispatcherServlet을 래핑한다. `perform()` 메서드로 요청을 보낼 때마다 **MockMvc는 TestDispatcherServlet을 사용한다. 따라서 실제 네트워크 연결이 이루어지지 않으므로 MockMvc를 사용하는 동안 전체 네트워크 스택을 테스트할 수 없다.**\n\n또한 Spring은 HTTP 요청과 응답을 모킹하기 위해 웹 애플리케이션 컨텍스트를 가짜로 준비하기 때문에 스프링 애플리케이션의 모든 기능을 지원하지 않을 수도 있다.\n\n예를 들면, 이 모킹 설정은 HTTP 리다이렉션을 지원하지 않는다. 스프링 부트는 요청을 /error 엔드포인트로 리다이렉션하여 일부 오류를 처리하기 때문에, MockMvc를 사용하는 경우 일부 api 오류를 테스트하지 못할 수 있다.\n\nMockMvc의 대안으로, 보다 실제적인 애플리케이션 컨텍스트를 설정한 다음 RestTemplate 또는 REST-assured를 사용하여 애플리케이션을 테스트할 수 있다.\n\n> 출처: https://www.baeldung.com/integration-testing-in-spring\n\n# 스프링 부트와 함께 테스트하기\n```java\n@SpringBootTest\npublic class TestingWebApplicationTests {\n\n\t@Test\n\tpublic void contextLoads() {\n\t}\n\n}\n```\n`@SpringBootTest` 어노테이션은 스프링 부트가 기본 구성 클래스(예: `@SpringBootApplication`이 있는 클래스)를 찾고 이를 사용하여 스프링 애플리케이션 컨텍스트를 시작하도록 지시한다. 다음과 같이 assertion을 추가할 수 있다.\n\n```java\n@SpringBootTest\npublic class SmokeTest {\n\n\t@Autowired\n\tprivate HomeController controller;\n\n\t@Test\n\tpublic void contextLoads() throws Exception {\n\t\tassertThat(controller).isNotNull();\n\t}\n}\n```\n스프링은 `@Autowired` 어노테이션을 해석하고, 컨트롤러는 테스트 메서드가 실행되기 전에 주입된다.\n\n> 스프링 테스트에서는 테스트 간 애플리케이션 컨텍스트가 캐시된다. 하나의 테스트 케이스에 여러 메서드가 있거나 동일한 구성을 가진 여러 테스트 케이스가 있는 경우 애플리케이션을 시작할 때 한 번만 비용이 발생한다. @DirectContext 어노테이션을 사용하여 캐시를 제어할 수 있다.\n\n```java\n@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)\npublic class HttpRequestTest {\n\n\t@Value(value=\"${local.server.port}\")\n\tprivate int port;\n\n\t@Autowired\n\tprivate TestRestTemplate restTemplate;\n\n\t@Test\n\tpublic void greetingShouldReturnDefaultMessage() throws Exception {\n\t\tassertThat(this.restTemplate.getForObject(\"http://localhost:\" + port + \"/\",\n\t\t\t\tString.class)).contains(\"Hello, World\");\n\t}\n}\n\n```\n**`webEnvironment=RANDOM_PORT`로 임의의 포트로 서버를 시작하여 테스트 환경에서 충돌을 피할 수 있다. `@LocalServerPort`로 포트를 주입하는 것에 유의해야 한다.** 또한 Spring Boot에서 자동으로 `TestRestTemplate`을 제공한다. `@Autowired`를 추가하기만 하면 된다.\n\n스프링이 HTTP 요청을 처리하고 이를 컨트롤러에 전달하도록 할 때 서버를 전혀 시작하지 않고 그 아래 레이어만 테스트하는 방식으로 접근해볼 수 있다. 이렇게 하면 서버를 시작하는 데 드는 비용 없이 실제 HTTP 요청을 처리하는 것과 똑같은 방식으로 코드가 호출된다. 이렇게 하려면 MockMvc를 사용하고 테스트 케이스에 `@AutoConfigureMockMvc` 어노테이션을 사용하여 주입되도록 요청하면 된다.\n\n```java\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class TestingWebApplicationTest {\n\n\t@Autowired\n\tprivate MockMvc mockMvc;\n\n\t@Test\n\tpublic void shouldReturnDefaultMessage() throws Exception {\n\t\tthis.mockMvc\n        \t.perform(get(\"/\"))\n            .andDo(print())\n            .andExpect(status().isOk())\n\t\t\t.andExpect(content().string(containsString(\"Hello, World\")));\n\t}\n}\n```\n> 출처: https://spring.io/guides/gs/testing-web/\n\n# 여전히 어렵지만\n여전히 위의 내용을 100% 이해하진 못했다. 그래도 안개가 한겹은 걷힌 기분이 든다. 아 그때 작성한 코드가 그래서.. 아 그때 하셨던 말씀이 그래서.. 라는 생각도 들었다. 알아야할게 아직 산더미지만 그래도 쪼끔이나마 나아갔다는 점에서 아주 뿌듯하다!",
      "short_description": "테스트 메서드에 @Transactional 좋다 vs 안좋다\n업무와 관련하여 테스트 코드에 대해 이야기를 나누던 중, 동료 분이 테스트 메서드에 @Transactional 어노테이션을 붙이는건 좋지 않을 수 있다며 블로그 링크를 하나 보내주셨다. 요약하자면, @Tran",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": null,
      "comments_count": 0,
      "url_slug": "깡통-탈출-프로젝트-1",
      "likes": 1,
      "liked": false,
      "user": {
        "id": "e365a225-b8dd-442c-ab9b-4bbb1d238c66",
        "username": "hyemin916",
        "profile": {
          "id": "dc770e26-f93d-44d0-9aa1-d920ee3c2bf0",
          "display_name": "햄햄",
          "thumbnail": "https://velog.velcdn.com/images/hyemin916/profile/593cf1c8-283b-4a9d-8fa0-e523b2ef7e21/image.jpeg",
          "short_bio": "@Ktown4u 개발자",
          "profile_links": {},
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "햄's Devlog",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": {
        "id": "d633bbab-52c0-45b5-b964-8b84f58410cf",
        "name": "깡통 탈출 프로젝트",
        "url_slug": "깡통-탈출-프로젝트",
        "series_posts": [
          {
            "id": "0f2b10f3-801f-4c00-9fee-8f6851832bca",
            "post": {
              "id": "d4c5f01d-19f4-4dbe-9dfa-96a1bff7f713",
              "title": "깡통 탈출 프로젝트 Intro",
              "url_slug": "깡통-탈출-프로젝트-Intro",
              "user": {
                "id": "e365a225-b8dd-442c-ab9b-4bbb1d238c66",
                "username": "hyemin916",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "75a2502f-d949-4553-b124-0d1e51180bec",
            "post": {
              "id": "d70f140c-62ea-4461-b19b-59d307b29cf4",
              "title": "깡통 탈출 프로젝트 #1 - MockMvc와 random port",
              "url_slug": "깡통-탈출-프로젝트-1",
              "user": {
                "id": "e365a225-b8dd-442c-ab9b-4bbb1d238c66",
                "username": "hyemin916",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": {
          "id": "d4c5f01d-19f4-4dbe-9dfa-96a1bff7f713",
          "title": "깡통 탈출 프로젝트 Intro",
          "url_slug": "깡통-탈출-프로젝트-Intro",
          "user": {
            "id": "e365a225-b8dd-442c-ab9b-4bbb1d238c66",
            "username": "hyemin916",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": null,
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "8b17f5ef-7b27-44c4-b4cd-5099d91104d0",
      "title": "🧑🏻‍🏫 프론트엔드 기술 면접 단골 개념들 정리 (자바스크립 편)",
      "released_at": "2023-03-07T10:20:42.619Z",
      "updated_at": "2023-03-22T01:38:15.086Z",
      "tags": [
        "기술면접"
      ],
      "body": "> 계속 추가할 예정입니다.\n\n## 🧑🏻‍🏫 자바스크립트 엔진\n자바스크립트가 동작되게 하려면 브라우저 자체에서 내장되어있는 **JS 엔진이 필요**하다. 이것이 **동작하는 시간을 런타임**이라고 하는데 런타임 하는 과정에서 코드를 **한 줄 한 줄 읽고 번역해서 실행을 해주는 것**이 **인터프리터** 라고 한다.\n\n\n## 🧑🏻‍🏫 자바스크립트란?\n\n- 자바스크립트는 가볍고 인터프리터를 이용해서 런타임 시 한 줄 한 줄 번역해준다.\n- 일급 함수를 가진 언어이며 자바스크립트 엔진이 있는 어떤 곳이든 사용할 수 있다.\n- 자바스크립트는 프로토타입을 베이스로 다양한 스타일로 구현이 가능하고 **멀티 페러다임**이다. (**절차지향으로도 가능하고 객체지향으로도 가능**하다.)\n- **싱글 스레드**다.\n- 자바스크립트는 언어 자체만으로도 할 수 있는것이 그리 많지 않다. 브라우저에서 무언가를 출력하고 싶다면 외부 환경에 출력을 도와줄만한 라이브러리를 사용해야한다.\n- 네트워크 통신을 하려면 통신을 할 라이브러리를 사용해야 한다.\n\n\n## 🧑🏻‍🏫 스코프란?\n\n- 변수를 참조(=접근)할 수 있는 유효한 범위, 영역을 지정하는 것을 말한다.\n- 선언 된 위치에 따라 유효 범위가 결정된다.\n- 범위는 코드 블록 `{ }` 안에서만 유효한다.\n- 블록 밖에서는 참조할 수 없다.\n\n🔥 장점 \n1. 이름 충돌이 방지된다.\n2. 메모리를 절약할 수 있다.\n\n🔥 결론\n\n- 변수는 최대한 필요한 곳에서 정의해야한다!\n\n🔥 코드 블록이 쓰이는 곳들\n\n```\n{ }\n\nif() {\n\n}\n\nfor() {\n\n}\n\nfunction() {\n\n}\n```\n\n\n<br>\n\n## 🧑🏻‍🏫 지역변수\n\n```\nfunction sum (a, b) {\n  console.log(a,b)\n} // 이런 매개변수들도 블록안에서만 접근이 가능하다.\n```\n- 블록 외부에서는 블록 내부 변수를 참조할 수 없다.\n- 함수 외부에서는 함수 내부의 변수를 참조할 수 없다.\n- 함수 외부에서는 함수 매개변수를 참조할 수 없다.\n\n\n```\n{\n  const x = 1;\n  {\n    const y = 2;\n    console.log(x); \n  }\n    console.log(x); // 1\n    console.log(y); // 블록 외부에서는 내부를 참조할 수 없으므로 앱이 죽는다.\n}\n```\n\n`const x = 1` 은 전체적인 코드 블록 내부에서 유효하다. 그래서 안에서 외부를 접근할 수 있다.\n\n<br>\n\n## 🧑🏻‍🏫 글로벌 스코프\n\n```\n// 📍 전역 변수, 전역 스코프, 글로벌 변수, 글로벌 스코프 라고한다.\nconst text ='global'; \n\n{\n// 📍 지역 변수, 로컬 변수, 지역 스코프, 로컬 스코프\n  const text = 'inside block1'; \n  {\n    console.log(text)\n  }\n}\n```\n- 답은 'inside block1' 이 된다. 내부에 있는 것은 외부에 있는 것에 접근이 안되기 때문에. 만약 inside block1 값이 없다면 한 단계 위로 상위 변수에 접근할 수 있다. 쉽게 말해 **가장 가까운 근접한 변수에 접근 하는 것**이다.\n\n<br>\n\n## 🧑🏻‍🏫 가비지 컬렉터 (= 쓰레기 수집)\n- 프로그래밍을 할 때 쓰레기 수집을 해줘야한다. 여기서 말하는 쓰레기 수집이란 메모리 청소를 해줘야 한다는 뜻으로 보면 된다.\n\n### 메모리 구조\n\n```\nlet apple = {\n  name : 'apple',\n}\n\nlet orange = apple;\n\norange = null;\napple = null;\n```\n\n오브젝트를 변수에 할당하면 오브젝트는 메모리 어딘가에 heap이라는 곳에 만들어진다. 변수는 메모리가 만들어진 주소를 가리키게 된다. 그런데 메모리 안에 아무것도 없을 경우에 (Null) 참조하는 것이 없다면, 쓰레기로 간주하고 메모리에서 깔끔하게 청소를 해준다.\n\n자바스크립트에서 가비지 컬렉션이 발생하는 원리는 가비지 컬렉터라는 애가 있는데 자바스크립트 엔진 자체에서 제공해주고 백그라운드 프로세스에서 동작해준다. 대신 이런 점에서 CPU가 발생하게 된다. (즉, 비용이 발생한다는 것!!)\n\n```\nconst global = 1;\n{\n const local = 1;\n}\n```\n\n이처럼 글로벌 변수는 앱이 종료될 때까지 계속 메모리에 유지된다. 블록 스코프는 블록 스코프의 역할이 끝나면 자동으로 소멸된다. => 가비지 컬렉터가 메모리를 처리해줌.\n그래서 가급적 글로벌하게 전역적으로 쓰는 것은 좋지 않다 ❌\n메모리 측면에서 좋지 않기 때문에 가급적이면 필요한 곳에서만 사용하는 것이 좋다. 👍\n\n<br>\n\n## 🧑🏻‍🏫 렉시컬 환경\n\n렉시컬 환경을 알아보기 전에 실행 컨텍스트에 대해 짧게 알아보자.\n\n### 실행 컨텍스트\n- 콜스택과 밀접하게 관련이 있다. 코드의 실행 순서와 스코프를 기억하고 있기 때문이다.\n- 내부에서 외부로 접근이 가능했다. 전역에서 선언된 것을 전역 스코프라 하고 내부에 있는 것을 블록 스코프라고 한다. 블록 안에 또 다른 스코프가 존재할 수도 있다.\n\n```\nconst a = 1;\n{\n  const a = 2;\n   {\n    const a = 3;\n   }\n}\n```\n\n이러한 코드가 있다고 가정했을 때, `근접한 부모에 스코프를 어떻게 찾는걸까 ?` 했다면 이유는 각각의 블록에서는 렉시컬 환경이라는 내부 오브젝트를 가지고 있다. 그래서 `각 블록마다 어떤 변수가 들어있는지 부모는 누구인지?` 이런 것을 추적하는 것이 **렉시컬 환경**이라고 한다.\n\n자바스크립트 엔진은 이런 실행 순서와 각각의 블록의 정보들을 한 오브젝트에 데이터를 담아두고 있다.\n\n### 렉시컬 환경 안에 속해있는 것들은 이와 같다.\n1. 환경 레코드\n2. 외부 환경 참조\n\n### 실행 컨텍스트 스택\n\n```\nconst a = 1; // 전역 스코프\n{\n  const a = 2; // 블록 스코프 1\n   {\n    const a = 3; // 블록 스코프 2\n   }\n}\n```\n\n- 이와같이 전역 스코프 렉시컬 환경이 만들어졌음\n- 위처럼 블록 스코프1의 렉시컬 환경이 있고 블록스코프2가 있다. 이렇게 이어지는 것을 **스코프 체인**이라고 한다.\n\n### 렉시컬 환경과 스코프 체인를 통해 배운점\n\n1. 메모리 절약 뿐만 아니라 성능을 위해서라도 변수는 **최대한 필요한 곳에 정의** 해야되는구나\n2. 중첩된 스코프나 중첩된 함수가 있다면 모든 체인을 검사하며 돌아다니니 **성능에 좋지 않겠다.**\n\n### 스코프 개념 정리\n\n스코프는 식별자가 유효한 범위를 나타내는데, 스코프 밖에서는 스코프 내부에 있는 것을 접근할 수 없지만 스코프 내부에서는 스코프 외부에 있는 어떤 부모의 데이터도 접근할 수 있다. \n**접근할 수 있는 이유는?** 렉시컬 환경 참조와 스코프 체인을 통해 부모에 접근할 수 있는 것이다!\n\n<br>\n\n## 🧑🏻‍🏫 호이스팅\n- 자바스크립트 엔진(인터프리터)이 코드를 실행하기 전에 변수와 함수, 클래스의 선언문을 끌어올리는 것을 말한다.\n- 변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮긴다.\n\n### 변수\n- 값을 저장할 수 있는 공간\n- 자료를 저장할 수 있는 이름이 주어진 기억 장소\n\n보통 let과 const를 많이 사용한다.\n- let : 재할당이 필수로 필요할 경우에만 사용\n- const : 재할당이 필요 없는 경우 (가능한 const 선호)\n\n위 변수 키워드가 생기기 전까지는 문제 덩어리인 `var`를 사용했다.\n\n#### 어떤 이유로 var를 쓰지 말라고 한 것일까?\n기본적으로 함수의 호이스팅은 함수의 선언문 전에 호출이 가능하게 해준다.\n함수의 선언문은 선언 이전에도 호출이 가능하다는 것이다.\n\n```\nprint();\n\nfunction print() {\n  console.log('hello');\n}\n```\n\n하지만 ! 변수는 변수 선언하기 이전에 호출하면 앱이 죽어버린다.\n\n```\nconsole.log(hi); // ☠️\nlet hi = 'hi';\n```\n\n함수 선언만 호이스팅이 가능해서 호출이 가능하고, 변수(let, const)와 클래스는 선언된 이름만 호이스팅이 가능하고 값 자체는 순서대로 코드 차례가 왔을 때만 가능하다.\n\n\n### var\n\n![](https://velog.velcdn.com/images/leemember/post/3f3147c3-1918-4901-bd6f-e5a126b332ef/image.png)\n\nvar는 let과 const와 다르게도 호출이 가능함!\n이것 뿐만 아니라 var의 다른 특징에 대해서도 읊어본다면\n\n### 특징\n- 코드의 가독성과 유지보수성에 좋지 않다.\n- 변수를 선언하는 키워드 없이 선언과 할당이 가능하다.\n- 선언인지 재할당인지 구분하기 어렵다.\n- 중복선언이 가능하다--> var라는 변수를 한 번 선언하게 되면 선언하고 나서 다시 똑같은 이름으로 재선언이 가능하다.\n\n```\nvar hi = '1';\nvar hi = '2';\n```\n\n이렇게 가능! 그래서 let을 사용하면 재선언 할 수 없다고 친절하게 오류 문구로 안내가 되지만 var는 가능\n\n- 블록 레벨 스코프 지원이 안된다. 함수 레벨스코프만 지원된다.\n\n<br>\n\n## 🧑🏻‍🏫 엄격모드\n리액트와 같은 프레임워크 사용시 기본적으로 엄격모드가 탑재되어있다.\n그래도 엄격모드가 뭔지 알아보자.\n\n```\nfor(i=1; i<5; i++) {\n\n}\n```\n\n이런식으로 선언하게 될 경우, 변수 선언 키워드를 제대로 사용하지 않았을 때\n엄격모드를 사용하면 자바스크립트의 나쁜 버릇들을 잡아준다.\n\n<br>\n\n## 🧑🏻‍🏫 클로저\n- 이름만 봐도 폐쇄, 닫히는 듯한 느낌이 든다.\n- 자바스크립트에서 클로저란 콤비네이션이라고 보면된다. 바로 함수와 그 외부를 둘러싸고있는 렉시컬 환경의 조합이라고 보면 되는데, 쉽게 말해 내부 함수와 그 외부에 있는 함수의 스코프를 접근할 수 있는 것을 클로저라고 한다.\n\n```\nfunction outer() {\n const x = 0;\n \n function inner() {\n   x; // 감싸고있는 함수의 변수에 접근이 가능하다. 이유는 클로저 버프 때문\n }\n inner();\n}\nouter();\n```\n\n이런 함수가 있다고 본다면, **실행 컨텍스트 스택**에 **전역 스코프 렉시컬 환경**이 먼저 들어오고 그 다음에 **outer라는 스코프 렉시컬 환경**이 들어온다. 그래서 outer 렉시컬 **환경 안에 inner 스코프**가 들어오게 된다. \n\n\n### 클로저를 사용하는 이유\n\n- 또한 클로저는 내부 정보를 은닉하고, 공개 함수(public, 외부)를 통한 데이터 조작을 위해 쓰인다. \n- 캡슐화와 정보은닉을 위해 쓰인다.\n- 클래스 private 필드 또는 메소드를 사용하는 효과와 동일하다.\n\n\n<br>\n\n## 🧑🏻‍🏫 this\n\n> 문맥에 따라 이것이 가리키는 것이 달라진다.\nthis는 내가 앞으로 만들어질 인스턴스나, 객체 자기 자신을 가리키는 용도로 사용됐다. 특정한 객체와 this를 묶어놓은 것은 this 바인딩이라고 칭한다.\n자바스크립트에서 this는 다른 언어들과 다르게 사용된다. 자바나 C, C++ 같은 경우 this는 하나의 인스턴스에 고정되지만, 자바스크립트 또는 타입스크립트는 런타임 상에서 this 바인딩이 동적으로 결정된다.\n\n### 글로벌 컨텍스트에서 this란?\n\n글로벌 컨텍스트는 기본적으로 2가지가 있다. (1) 브라우저 (2) Node 가 있는데\n- 🙌 브라우저 --> this는 window 다. window에 탑재된 속성들이 출력되는 것을 볼 수 있다.\n- 🙌 노드 --> 모듈을 가리킨다. 콘솔로그에 노드의 this를 출력하면 텅텅 빈 객체가 출력이 된다. `globalThis` 를 출력하면 노드에서 사용되는 전역 객체들이 출력된다.\n\n(ex) setTimeout, setInterver 같은 것들\n\n### 함수 내부에서 this\n\n```\nfunction hello() {\n  console.log(this)\n}\nhello();\n```\n\n- 엄격모드 (use stric)를 사용하게 될 경우는 undefined가 뜬다.\n- 느슨한 모드에서는 globalThis를 가리키는 것을 확인해볼 수 있다.\n\n### 생성자함수 또는 클래스에서 this\n- 앞으로 생성될 인스턴스 자체를 가리킨다. == 동적바인딩\n\n### 동적바인딩\n- 현재 this는 누구인지 모른다. 누가 호출하냐에 따라 this가 달라진다.\n\n### 정적바인딩\n- this라는 함수가 계속 동적으로 변경되기 때문에 이걸 정적으로 얼려버리는 방법이 있다.\n\n1. bind 라는 함수를 이용하여 수동적으로 바인딩 해준다.\n\n```\nthis.myName = this.myName.bind(this)\n```\n\n2. 화살표 함수 사용\n- 이것은 렉시컬 환경에서 this를 기억한다.\n\n```\nthis.myName = () => {\n  console.log(`하이 ${this.name}`);\n}\n```\n\n이런식으로 사용할 수 있다.\n\n\n### 화살표 함수의 특징\n1. 문법이 깔끔\n2. 생성자 함수로 사용이 불가능하다.\n3. 함수 자체 arguments\n4. this에 대한 바인딩이 정적으로 결정된다.\n(함수에서 제일 근접한 상위 스코프의 this에 정적으로 바인딩 된다)\n\n<br>\n\n## 🧑🏻‍🏫 타입스크립트 사용하는 이유\n1. 타입을 직접 지정해주고 컴파일 시점에 에러를 잡아낼 수 있다.\n2. 만약 변수에 지정된 타입이 아닌 다른 타입을 지정해주면 에러가 발생한다.\n\n이런 이유들로 인해 코드의 안전성과 더 나은 개발 디버깅이 가능하다. 데이터가 어떤 타입인지 직관적으로 알 수 있음! 그래서 코드 퀄리티를 높혀준다.\n\n## 이벤트 캡쳐링과 버블링\n\n### 이벤트 캡쳐링\n- 부모 컴포넌트에서 시작돼서 자식까지 이벤트의 영향을 끼친다.\n\n### 이벤트 버블링 (⭐️이게 더 중요)\n\n- 상위에 있는 부모에게 이벤트가 호출하게 된다. 또 그 위의 상위 부모한테도 이벤트가 호출된다. \n- `event.stopPropagation()`는 위로 전달하는 것을 중지 시켜준다. 하지만 가능하면 사용하지 않는 것이 좋다.\n",
      "short_description": "자바스크립트가 동작되게 하려면 브라우저 자체에서 내장되어있는 JS 엔진이 필요하다. 이것이 동작하는 시간을 런타임이라고 하는데 런타임 하는 과정에서 코드를 한 줄 한 줄 읽고 번역해서 실행을 해주는 것이 인터프리터 라고 한다.자바스크립트는 가볍고 인터프리터를 이용해서 ",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/leemember/post/49395593-99f6-480c-a2f8-95d076392fcb/image.gif",
      "comments_count": 4,
      "url_slug": "프론트엔드-개발자-기술-면접-단골-개념들-자바스크립편",
      "likes": 237,
      "liked": false,
      "user": {
        "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
        "username": "leemember",
        "profile": {
          "id": "a6d193d8-e94f-471c-9bd5-2a4025b54103",
          "display_name": "leehyunju",
          "thumbnail": "https://images.velog.io/images/leemember/profile/c8ee5d39-820e-4fab-909d-4cd8d695609f/social.jpeg",
          "short_bio": "아늑한 뇌공간  🧠",
          "profile_links": {
            "email": "hyunmail521@gmail.com",
            "github": "leemember"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": null,
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [
        {
          "id": "76b83f1e-5163-44ca-9843-cbda804abe18",
          "user": {
            "id": "4067e18d-5aff-4698-9f2c-b67bcd8cc860",
            "username": "jmyoon8",
            "profile": {
              "id": "65b61c9c-8acd-4f55-a06f-b92ab6de454f",
              "thumbnail": "https://images.velog.io/images/jmyoon8/profile/176988fe-b499-48bd-9cfd-1d81abc08b74/Developer.jpg",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "알던거였는데 다 까먹었네요 나중에 다시한번 공부해야 겠습니다",
          "replies_count": 1,
          "level": 0,
          "created_at": "2023-03-14T10:03:11.021Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "21bc5d0d-72bf-4611-ab3a-4e9273da32f7",
          "user": {
            "id": "840e7016-3453-4a82-9357-b16289b881c4",
            "username": "x5foddl",
            "profile": {
              "id": "af33fd81-c104-47ba-910c-f8378a364f9a",
              "thumbnail": null,
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "감사합니다 !",
          "replies_count": 1,
          "level": 0,
          "created_at": "2023-03-15T05:48:38.735Z",
          "deleted": false,
          "__typename": "Comment"
        }
      ],
      "series": {
        "id": "fe77c9ae-1ad3-4ce6-b511-1ec1df7b5f7a",
        "name": "FE면접준비",
        "url_slug": "FE면접준비",
        "series_posts": [
          {
            "id": "1ace7e89-e9c1-4b4e-9b22-e670145d83ff",
            "post": {
              "id": "8b17f5ef-7b27-44c4-b4cd-5099d91104d0",
              "title": "🧑🏻‍🏫 프론트엔드 기술 면접 단골 개념들 정리 (자바스크립 편)",
              "url_slug": "프론트엔드-개발자-기술-면접-단골-개념들-자바스크립편",
              "user": {
                "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
                "username": "leemember",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "a736abb7-9a11-4c3b-9ea1-aa51d3d4d378",
            "post": {
              "id": "8409dbc7-2a02-4987-90ef-8a3b713b7b60",
              "title": "🧑🏻‍🏫 프론트엔드 기술 면접 단골 개념들 정리 (리액트 편)",
              "url_slug": "프론트엔드-기술-면접-단골-개념들-정리-리액트-편",
              "user": {
                "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
                "username": "leemember",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": null,
        "next": {
          "id": "8409dbc7-2a02-4987-90ef-8a3b713b7b60",
          "title": "🧑🏻‍🏫 프론트엔드 기술 면접 단골 개념들 정리 (리액트 편)",
          "url_slug": "프론트엔드-기술-면접-단골-개념들-정리-리액트-편",
          "user": {
            "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
            "username": "leemember",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "2cfc0328-ad4c-4861-8f8c-b42969fe90bb",
      "title": "Docker로 프론트엔드 프로젝트 생성 명령어를 통일해보자",
      "released_at": "2023-02-04T11:50:16.806Z",
      "updated_at": "2023-03-22T01:32:59.025Z",
      "tags": [
        "docker",
        "프론트엔드"
      ],
      "body": "> 영양가 없는 흥미 위주 글입니다.\n\n프론트엔드에서 프로젝트를 시작하는 것은 굉장히 편하다. 굳이 `create-react-app` 이나 `create-next-app` 에 대한 이야기를 하지 않더라도 누구나 공식 문서를 통해 프로젝트를 시작할 수 있다. 심지어 이런 라이브러리들이 의존하는 프로세스는 기껏해야 nodejs 뿐이다. 그렇다면 Docker를 사용해서 FE 프로젝트를 생성하는 것이 뭐가 좋을까? 사실 FE 프로젝트 생성이 단순하기 때문에 가능한 개선점이 있다.\n\n> ??? : 왜 이렇게 하냐구요? 간지나서 하는거에요.\n\nFE 프로젝트는 시작하는 방법이 많고 생성 명령어가 비슷하긴 해도 똑같지는 않다. 이를 해결한다면 프로젝트를 시작할 때 아주 약간의 생성성을 올릴 수 있다. **필자는 CRA, CNA, vite, svelte 등 모든 프로젝트 생성 명령어를 외우고 싶지 않다. Docker를 이용해서 프로젝트 생성 명령어를 통일해보자.**\n\n\n### Dockerfile\n\n\n```Dockerfile\n#create-next-app.dockerfile\n\nFROM node:lts\n\nWORKDIR /app\n\nENTRYPOINT npx create-next-app@latest\n\n```\n\n`node:lts` 이미지를 활용한다. 작업 디렉토리를 원하는대로 설정해주고 엔트리포인트에 공식문서에 적혀있는 프로젝트 생성 커맨드를 설정해주자. 다양한 옵션들을 프로젝트 생성 시점에 정해주기 위해 `CMD` 가 아닌 `ENTRYPOINT` 를 이용한다.\n\nNext 프로젝트가 아닌 다른 라이브러리도 이와 유사하게 도커 파일을 생성해주자.\n\n### docker-compose.yaml\n\n프로젝트를 생성할 때마다 도커 명령어를 작성하고 있는 것은 생산성이 오히려 더 떨어질 것이다. 따라서 미리 docker-compose를 통해서 다양한 도커 옵션들을 정의해줄 것이다.\n\n```\n#docker-compose.yaml\n\nversion: '3.8'\nservices:\n  next:\n    build:\n      context: .\n      dockerfile: #your dockerfile path\n    stdin_open: true\n    tty: true\n    volumes:\n      - ./:/app\n```\n\n`stdin_open`, `tty` 값을 `true` 설정하여 attach, interactive 모드로 실행할 것이다. 컨테이너 내에 생성된 프로젝트를 로컬 머신으로 들고 오기 위해서 바인드 마운트를 이용한다. 바인드 마운트라는 것은 컨테이너와 로컬 경로의 싱크를 맞추기 위한 것이다. 보통은 개발용 컨테이너에서 사용하고 바인드 마운트를 이용하면 코드 변경이 있어도 이미지를 리빌드 할 필요가 없기 때문에 생성성을 높일 수 있다. 우리는 바인드마운트가 컨테이너와 로컬의 싱크를 맞춘다는 점을 역이용하여 컨테이너에 있는 파일을 로컬로 가지고 올 것이다.\n\n\n### 프로젝트 생성\n\n이제 프로젝트를 생성할 시간이다. docker-compose.yaml 파일이 프로젝트를 생성할 디렉토리에 있다면 다음과 같은 명령어로 프로젝트를 생성할 수 있다.\n\n```shell\ndocker compose run --rm <service-name> <option>\nex) docker compose run --rm next --typescript\n```\n\n`docker compose run` 은 yaml 파일 내 각각의 서비스를 실행하기 위한 명령어이고, run을 통해 컨테이너를 실행하면 종료 시에 컨테이너를 자동으로 제거하지 않기 때문에 --rm 옵션을 넣어주었다. 환경변수를 위해 -e 옵션을, 이미지 리빌드를 위해 --build 옵션을 추가로 넣어줄 수 있을 것이다.\n\n### 무엇이 좋아졌는가?\n\n`npx create-next-app@latest` 에서 `docker compose run --rm next` 명령어로 바뀌었다. 도커에 익숙하지 않다면 더 귀찮기만 하다. 하지만 어떤 라이브러리라도 위와 같이 도커파일로 만든다면 아래의 명령어로 모든 프로젝트 생성 명령어를 통일할 수 있다.\n\n```shell\ndocker-compose run --rm <service-name> project-name <option>\n```\n\n`docker-compose run --rm` 을 create 라는 문자로 치환해주면 어떨까. 상당히 매력적일 것 같다. `alias` 명령어를 이용하여 로컬 터미널의 명령어 별칭을 지어줄 수 있다. 예를 들면 이렇다.\n\n```shell\nalias c=\"cat\"\n```\n이제 cat 명령어는 c만 입력해도 사용 가능하다. 그럼 이것도 가능하지 않을까?\n\n```shell\nalias create=\"docker-compose run --rm\"\n```\n\n![](https://velog.velcdn.com/images/jeonbyeongmin/post/c4ff76dd-87a8-441a-80e0-59e2c20bab66/image.png)\n\n\n마음에 든다. next 앱은 `create next` 명령으로 svelte 앱은 `create svelte` 명령으로 React 앱은 `create react` 명령으로, 이제 무엇이든 `create <something>` 으로 만들 수 있게 되었다. 다만 이러한 방법은 Dockerfile, docker-compose 파일을 만들어두어야 사용할 수 있다는 한계가 있다. 또 애초에 그다지 많은 라이브러리를 사용할 이유가 없는 사람이라면 더더욱 이럴 필요가 없다. 특히 `alias` 명령어만을 활용해도 꽤나 큰 효과를 볼 수 있다.\n\n그렇지만 nodejs 없이도 프로젝트를 시작할 수 있다는 점, 또 그 프로젝트 스타터를 Dockerfile을 통해 명시적으로 관리할 수 있다는 점, 프로젝트 생성 명령어 (많은 옵션이 포함된)를 일일이 기억하고 있지 않아도 된다는 점은 꽤나 매력적이다. \n\n> [frontend starter dockerfiles repository](https://github.com/jeonbyeongmin/frontend-starter-dockerfiles)\n\n\n\n",
      "short_description": "주의 : 영양가없는 글입니다.프론트엔드에서 프로젝트를 시작하는 것은 굉장히 편하다. 굳이 create-react-app 이나 create-next-app 에 대한 이야기를 하지 않더라도 누구나 공식 문서를 통해 프로젝트를 시작할 수 있다. 심지어 이런 라이브러리들이 의",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/jeonbyeongmin/post/510c5f70-7688-43b3-91ee-6e462c19c2a9/image.png",
      "comments_count": 0,
      "url_slug": "Docker로-FE-프로젝트-시작하기",
      "likes": 1,
      "liked": false,
      "user": {
        "id": "441c9a87-c730-4fcc-a123-9f73fca245d5",
        "username": "jeonbyeongmin",
        "profile": {
          "id": "e2a30b29-dce2-448d-9185-d88b5d0d6bc2",
          "display_name": "전병민",
          "thumbnail": "https://velog.velcdn.com/images/jeonbyeongmin/profile/9f0e7ea0-8a51-4875-b80d-b2573073c69a/image.jpeg",
          "short_bio": "강단있는 개발자",
          "profile_links": {
            "github": "jeonbyeongmin"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "강단",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": {
        "id": "8582c4ed-513b-48d9-8ca6-5d174176247f",
        "name": "실험실",
        "url_slug": "실험실",
        "series_posts": [
          {
            "id": "b3f9a686-53ff-4369-a122-71044fbadf8e",
            "post": {
              "id": "2cfc0328-ad4c-4861-8f8c-b42969fe90bb",
              "title": "Docker로 프론트엔드 프로젝트 생성 명령어를 통일해보자",
              "url_slug": "Docker로-FE-프로젝트-시작하기",
              "user": {
                "id": "441c9a87-c730-4fcc-a123-9f73fca245d5",
                "username": "jeonbyeongmin",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "788dad03-1f5e-49c1-862a-413703c09916",
            "post": {
              "id": "9b00c366-ed33-4729-b581-1a889db7af04",
              "title": "Chat GPT한테 코드리뷰 시켰습니다.. (feat. Github Action)",
              "url_slug": "Chat-GPT한테-코드리뷰-시켰습니다..-feat.-Github-Action",
              "user": {
                "id": "441c9a87-c730-4fcc-a123-9f73fca245d5",
                "username": "jeonbyeongmin",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": null,
        "next": {
          "id": "9b00c366-ed33-4729-b581-1a889db7af04",
          "title": "Chat GPT한테 코드리뷰 시켰습니다.. (feat. Github Action)",
          "url_slug": "Chat-GPT한테-코드리뷰-시켰습니다..-feat.-Github-Action",
          "user": {
            "id": "441c9a87-c730-4fcc-a123-9f73fca245d5",
            "username": "jeonbyeongmin",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "c7eff60c-2993-408a-805f-873b0229ae36",
      "title": "~개발진스 짤 데려가세요2~",
      "released_at": "2023-03-21T05:14:31.533Z",
      "updated_at": "2023-03-22T02:10:39.987Z",
      "tags": [
        "meme",
        "밈",
        "짤"
      ],
      "body": "> 그림쟁이 주니어 개발자가 그린 뉴진스 패러디 개발진스 짤 입니다.\n저장하시고 마음대로 사용하셔도 됩니다. (상업용은 안됨)\n많은 관심 감사합니다. 🥹❤️\n\n> 짤 요청이 너무 많아서 여러분이 직접 만들어 쓸 수 있는 페이지를 만들었어요. [(님들이)만들어쓰는 개발진스](https://velog.io/@heelieben/님들이-만들어쓰는-개발진스)\n\n### [~개발진스 짤 데려가세요1~](https://velog.io/@heelieben/개발진스-짤-데려가세요)\n\n\n\n## Devops 모여랏\n\n\n![](https://velog.velcdn.com/images/heelieben/post/675309bf-a0a3-4443-8ced-8a55ce40ce08/image.png)\n![](https://velog.velcdn.com/images/heelieben/post/bbd616dd-bd06-409a-a420-4a4e43e4d925/image.png)\n![](https://velog.velcdn.com/images/heelieben/post/3fc7f9ea-228e-4f3f-8335-903f6cde8ca9/image.png)\n![](https://velog.velcdn.com/images/heelieben/post/aae00279-723b-40e3-bcea-cb547b73b60f/image.png)\n\n## 백엔드 개발자도 껴주세요\n\n![](https://velog.velcdn.com/images/heelieben/post/2be03f69-3ac7-4013-bd5b-1a7662e7436d/image.png)\n\n![](https://velog.velcdn.com/images/heelieben/post/a0fd179b-0910-4825-9f1b-423010488429/image.png)\n\n![](https://velog.velcdn.com/images/heelieben/post/0fd6012b-1c07-4271-9a64-d8f92d65db2c/image.png)\n\n![](https://velog.velcdn.com/images/heelieben/post/3c15c708-c5b2-404e-858e-138241e90d77/image.png)\n\n![](https://velog.velcdn.com/images/heelieben/post/bc04851b-23e4-48ed-a3f8-d0173ba8e6b4/image.png)\n\n\n## 개발자는 아니지만 껴주세요 (간호사 ver)\n\n\n![](https://velog.velcdn.com/images/heelieben/post/d10e12af-0093-43df-9e9c-205f9086b759/image.png)\n\n![](https://velog.velcdn.com/images/heelieben/post/48b37773-025f-47c0-9e0e-ddb126274128/image.png)\n\n![](https://velog.velcdn.com/images/heelieben/post/89255d95-95d3-4077-b647-341f5be454e1/image.png)\n\n---\n\n\n인스타그램도 운영하고 있습니다. 놀러와주세요 ㅎㅎ\n\n> 인스타툰 링크: [@dev_hee](https://www.instagram.com/dev_hee/)",
      "short_description": "그림쟁이 주니어 개발자가 그린 뉴진스 패러디 개발진스 짤 입니다.저장하시고 마음대로 사용하셔도 됩니다. (상업용은 안됨)많은 관심 감사합니다. 🥹❤️개발진스 1탄인스타그램도 운영하고 있습니다. 놀러와주세요 ㅎㅎ인스타툰 링크: @dev_hee",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/heelieben/post/675309bf-a0a3-4443-8ced-8a55ce40ce08/image.png",
      "comments_count": 6,
      "url_slug": "개발진스-짤-데려가세요2",
      "likes": 19,
      "liked": false,
      "user": {
        "id": "fc7c4760-02ad-4ffe-9466-fe210b62662f",
        "username": "heelieben",
        "profile": {
          "id": "ac4fb0d3-4135-42b3-b1ae-fce84f087cee",
          "display_name": "pigme",
          "thumbnail": "https://velog.velcdn.com/images/heelieben/profile/e634958b-a3a5-424f-921a-66f8165923f9/image.png",
          "short_bio": "🎨그림을 좋아하는 FE 개발자👩🏻‍💻",
          "profile_links": {
            "url": "https://www.instagram.com/dev_hee/",
            "email": "kheeyaa888@gmail.com",
            "github": "kheeyaa"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "pigme의 기술 로그",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [
        {
          "id": "ccf2d1ed-7c19-479a-b307-faa9bf8ddd68",
          "user": {
            "id": "b79c4482-4251-4902-b131-af0e0f887018",
            "username": "zrston",
            "profile": {
              "id": "abed9976-19b5-406f-a88f-99dfe8e6f152",
              "thumbnail": "https://velog.velcdn.com/images/zrston/profile/fc91b42b-92b2-4533-9dbc-ab13a499bc83/social_profile.jpeg",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "ㅠㅠ 신작 너무 감사해요!",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-21T08:12:21.398Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "406d179d-6c7a-4f51-85fd-a0ad0077f227",
          "user": {
            "id": "109891f8-065f-4830-8121-70ad3310aa6d",
            "username": "jaepal",
            "profile": {
              "id": "5ae969a3-5dc8-4aa3-941f-e4a69f944578",
              "thumbnail": "https://velog.velcdn.com/images/jaepal/profile/657ec91b-9176-46e2-bb7f-0cedf777a128/image.jpeg",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "🥹🥹🥹",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-21T08:36:01.377Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "01f1901b-5752-49b7-af3b-904b76321456",
          "user": {
            "id": "53565ee0-db4e-4dba-b475-6c335451c185",
            "username": "soluinoon",
            "profile": {
              "id": "d7a4ac3f-8bdf-4b7c-8eeb-082a6451c7be",
              "thumbnail": "https://velog.velcdn.com/images/soluinoon/profile/c0def388-5d50-4793-a948-ae498e7e542a/social_profile.png",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "헐헐 완전 귀여워요 감사합니다",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-21T09:57:54.012Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "0ebb619b-ef27-4d59-a276-0fb6b03e5273",
          "user": {
            "id": "9b7f28d8-893b-4e77-92b7-53f3575cebe4",
            "username": "pak4184",
            "profile": {
              "id": "a9769a9b-e994-4785-b479-0555156d968a",
              "thumbnail": "https://velog.velcdn.com/images/pak4184/profile/4511e6fb-9210-4c1a-8010-6fa086d0f590/image.png",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "신작 너무 감사합니다...ㅋㅋㅋㅋㅋㅋㅋㅋ 벨로그 썸네일로 딱이에요 >_<",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-21T13:08:50.436Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "c1be276a-23b5-4123-a980-93d4fe86e6fa",
          "user": {
            "id": "15164cb6-4b39-4045-b25d-ef7020ccb726",
            "username": "saetakki93",
            "profile": {
              "id": "0338ce90-ad39-442f-967e-bf9a7579ddb5",
              "thumbnail": "https://velog.velcdn.com/images/saetakki93/profile/7b80dde7-6017-43ed-93b4-046600780e7d/image.png",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "저희 팀 프로젝트 팀원들이 일하다 말고 뛰쳐나와서 다 dev진스 + design진스로 프사 바꿨어요 보여드리고싶은데 사진 첨부가 안되네... ㅠㅠㅠ",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-21T14:24:57.892Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "02c3c0d7-058c-4b25-b460-db8ceb94c732",
          "user": {
            "id": "c9a2d0e0-890b-453a-ab3c-bff343eeaa54",
            "username": "jihye",
            "profile": {
              "id": "ed76a1e5-3bb8-4464-b445-3838d730dced",
              "thumbnail": "https://images.velog.io/images/jihye/profile/8ef84c2c-6c1f-48d3-99af-2af9f6abfee0/KakaoTalk_20210913_212908881.jpg",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "최고최고!! 스프링 개발자인데 회사 메신저에 프사로 써야겠어용 💕",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-22T00:40:22.187Z",
          "deleted": false,
          "__typename": "Comment"
        }
      ],
      "series": {
        "id": "093b835b-2ac1-447f-a920-a96cf21c4cd9",
        "name": "meme",
        "url_slug": "meme",
        "series_posts": [
          {
            "id": "231b45e4-4601-4f8c-af6a-42e280147a6e",
            "post": {
              "id": "58d1f777-cad7-47f5-85c7-cd190df8107d",
              "title": "~개발 공감 짤 구경하고 가세요~",
              "url_slug": "개발-공감-짤-구경하고-가세요",
              "user": {
                "id": "fc7c4760-02ad-4ffe-9466-fe210b62662f",
                "username": "heelieben",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "2076e3cb-e757-4243-9747-3c6a40abc36c",
            "post": {
              "id": "b3fcf1ab-6036-4a07-8ba8-d861fc8ee813",
              "title": "~개발진스 짤 데려가세요~",
              "url_slug": "개발진스-짤-데려가세요",
              "user": {
                "id": "fc7c4760-02ad-4ffe-9466-fe210b62662f",
                "username": "heelieben",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "7050b432-3963-44e9-b402-52a5afcdd384",
            "post": {
              "id": "c7eff60c-2993-408a-805f-873b0229ae36",
              "title": "~개발진스 짤 데려가세요2~",
              "url_slug": "개발진스-짤-데려가세요2",
              "user": {
                "id": "fc7c4760-02ad-4ffe-9466-fe210b62662f",
                "username": "heelieben",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": {
          "id": "b3fcf1ab-6036-4a07-8ba8-d861fc8ee813",
          "title": "~개발진스 짤 데려가세요~",
          "url_slug": "개발진스-짤-데려가세요",
          "user": {
            "id": "fc7c4760-02ad-4ffe-9466-fe210b62662f",
            "username": "heelieben",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": null,
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "58e6f300-d6e5-4078-9ffd-ee28ea2ba144",
      "title": "(번역) 웹 앱의 번들 크기를 줄이기 위해 할 수 있는 모든 것",
      "released_at": "2023-01-24T05:25:12.005Z",
      "updated_at": "2023-03-22T01:59:19.665Z",
      "tags": [],
      "body": "> 원문 : https://madelinemiller.dev/blog/reduce-webapp-bundle-size/\n\n웹팩과 같은 웹 번들러는 웹 앱을 배포하는 데 유용한 도구이지만, 더 복잡한 프로그램의 경우 번들 크기가 문제가 될 수 있습니다. 근본적인 문제와 솔루션은 사이트마다 다르지만 웹팩 및 다른 번들러가 가능한 작업을 잘 수행할 수 있도록 구현할 수 있는 몇 가지 변경 사항이 있습니다. 경우에 따라 동일한 문제가 다시 발생하지 않도록 방지하기 위한 린트(lint) 규칙 및 다른 방법들을 사용할 수도 있습니다. 이러한 변경 사항은 주로 리엑트, 타입스크립트 및 웹팩5를 염두에 두고 작성되었습니다. 그러나 문법과 이름은 다를 수 있지만, 일반적으로 모든 번들러를 거치는 모든 애플리케이션에 적용됩니다.\n\n## 웹 번들러는 번들을 어떻게 최적화할까요\n\n개선을 시작하기 전에 실제로 어떻게 동작하는지 이해하는 것이 중요합니다. 웹팩과 같은 웹 번들러는 코드와 코드에서 사용되는 다양한 종속성을 단일 파일로 번들하고 가능한 가장 적합하게 분할하려고 시도합니다. 이를 분할하는 프로세스를 번들 분할이라고 합니다. 웹팩은 또한 코드를 최소화하고 최적화하기 위해 터서(Terser)라는 도구를 사용합니다. 터서는 변수와 함수의 이름을 가능한 작게 변경하고 트리 쉐이킹으로 알려진 프로세스를 수행하여 응용프로그램에서 사용되지 않는 코드를 제거합니다.\n\n트리 쉐이킹은 복잡한 프로세스이므로 기능이 손상되지 않도록 신중하게 수행되어야 합니다. 코드가 앱의 동작에 영향을 줄 조금의 가능성이라도 있는 경우 터서는 코드를 제거하지 않습니다. 파일을 가져오기만 하고 함수를 호출하지 않아도 실행되는 동작들이 있는 경우가 있습니다. 이것들을 사이드 이펙트라고 부릅니다. 사이드 이펙트 감지는 가져오기 코드를 무시해도 안전한지 판단하기 위해 번들러와 같은 도구가 수행해야 하는 또 다른 복잡한 프로세스입니다. 가져온 파일을 사용하지 않지만 터서가 사이드 이펙트가 있을 수 있다고 신중하게 판단하는 경우 트리 쉐이킹이 발생하지 않습니다. 자바스크립트와 같은 동적 언어의 복잡성으로 인해 사이드 이펙트 감지는 거짓 양성(실제로는 음성인데, 양성으로 판단하는 경우)을 만들 수도 있습니다.\n\n또한 ESModule(또는 줄여서 ESM)과 같은 새로운 표준과 달리 CommonJS와 같은 오래된 모듈 표준은 트리 쉐이킹이 더 적게 일어납니다. 대부분의 번들러는 이러한 모듈 형식을 트리 쉐이킹하려고 시도하지 않거나, 시도할 경우 훨씬 더 신중하게 판단합니다.\n\n## 번들 크기 측정\n\n프로젝트 최적화를 수행할 때는 먼저 몇 가지 지표을 얻는 것이 좋습니다. 이 경우 번들의 크기와 번들에 포함된 내용을 이해해야 합니다. 일반적으로 번들의 진입점이 되는 부분은 가장 검토할 가치가 있습니다. 응용 프로그램의 구조에 따라 `main`으로 시작하는 이름, 페이지 경로 이름 또는 템플릿 파일 이름이 있을 수 있습니다.\n\n만약 웹팩을 사용하는 경우에는 [Webpack Bundle Analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer) 도구가 매우 유용할 수 있습니다. 이 플러그인 설정 및 활성화된 상태에서 웹팩 빌드를 실행하면 출력 디렉터리에 각 번들과 번들에 포함된 다양한 파일 및 종속성을 시각화하여 확인할 수 있는 HTML 파일이 생성됩니다.\n\n[Bundlewatch](https://github.com/bundlewatch/bundlewatch)와 같은 CI 파이프라인에 통합되는 툴도 있지만, 이러한 툴은 현재 문제에 대한 통찰력을 제공하는 것 보다는 번들 크기의 추가 증가를 방지하는 데 더 유용합니다.\n\n## 번들 크기 문제 해결\n\n### ESModule이 아닌 종속성\n\n번들 크기 증가의 가장 일반적인 원인 중 하나는 트리쉐이킹할 수 없는 CommonJS와 같은 모듈들입니다. 번들 분석을 통해 발견된 큰 크기의 종속성이 ESM 변형 패키지를 제공하는지 조사하는 것이 좋습니다. 이를 확인하는 빠른 방법은 `node_modules`의 종속성 `package.json` 파일 내에 `module` 항목이 있는지 확인하는 것입니다.\n\nESM 형식으로 제공되지 않는 모듈을 확인했으면 해당 모듈을 제공하는 업데이트가 있는지 확인하는 것이 좋습니다. NPM 페이지 또는 Github를 확인해보면 좋습니다. 종속성이 NPM 패키지 이름을 변경하는 경우가 있습니다. 예를 들어, `react-query`는 현재 ESM 릴리스를 포함하여 `@tanstack/react-query`로 변경되었습니다. 만약 사용 가능한 새 업데이트가 없는 경우 Github 이슈를 확인하면 이와 관련된 시간 범위 또는 토론이 있을 수 있습니다.\n\nESM 업데이트를 사용할 수 없는 경우에는 몇 가지 옵션이 있습니다. 대부분의 경우, 잠재적인 번들 크기 절감이 새로운 종속성으로 전환하는데 드는 개발 비용의 가치가 있는지 아니면 ESM 지원에 직접 기여할 가치가 있는지 결정하는 것이 중요합니다. ESM 형식으로 패키지를 재컴파일을 제공하는 [esm-bundle](https://medium.com/@joeldenning/an-esm-bundle-for-any-npm-package-5f850db0e04d)과 같은 일부 프로젝트가 있지만 빈번하게 종속성으로 사용되는 모듈에 대해 이러한 프로젝트로 구성하는 것은 문제가 될 수 있습니다.\n\n### TSConfig에서 CommonJS 모듈 타입\n\n번들러와 함께 타입스크립트를 사용하는 경우 많은 최적화를 비활성화 시키는 쉬운 실수는 TSConfig 파일의 `\"module\"` 속성을 `CommonJS`으로 설정하는 것입니다. 이것은 번들러의 실제 출력을 설정하는 것이 아니라 컴파일된 타입스크립트를 받는 중간 형식을 변경합니다. 대부분의 경우 이것은 `\"es2020\"`과 같은 ESM 형식으로 쉽게 변경할 수 있어야 합니다. Jest를 사용하는 경우에도 CommonJS 출력이 필요할 수 있습니다. 이 경우 첫 번째 파일(TSConfig)을 확장하지만 모듈을 다시 CommonJS로 설정하는 두 번째 `tsconfig.spec.json` 파일을 설정할 수 있습니다. 이를 통해 번들러는 ESM을 받을 수 있으며, Jest는 변경된 TSConfig를 사용하여 CommonJS를 유지하도록 설정할 수 있습니다.\n\n### 코드에 사이드 이펙트 없음을 표시\n\n웹팩과 같은 일부 번들러에서는 사이드 이펙트 감지 프로세스에 대한 힌트를 제공할 수 있습니다. 코드에 사이드 이펙트가 없는 경우 `package.json`에 \"`sideEffects\"` 속성 `false`로 설정할 수 있습니다. 이것은 라이브러리에 사이드 이펙트가 없기 때문에 훨씬 더 깊이 있는 트리 쉐이킹이 가능하다는 것을 번들러에게 알려줍니다. 리액트와 같은 라이브러리를 사용할 때 고차 컴포넌트와 같은 다양한 리액트 패턴이 사이드 이펙트 감지를 잘못 트리거 할 수 있기 때문에 이 효과는 훨씬 더 두드러질 수 있습니다.\n\n사이드 이펙트가 있지만, 어디에 있는지 정확하게 알고 있다면 `\"sideEffects\"` 속성에 사이드 이펙트가 있는 패턴의 목록을 전달할 수 있습니다. 구체적인 구문은 [웹팩 설명서](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free)에 나와 있습니다. 이를 통해 CSS 가져오기와 같은 상황에서 사이드 이펙트를 유지하면서 패키지를 대부분 사이드 이펙트가 없는 것으로 표시할 수 있습니다.\n\n#### 웹팩 규칙 사용\n\n더 복잡한 경우에는 웹팩 규칙을 통해 `sideEffects` 속성을 설정할 수도 있습니다. 이 기능은 보다 동적인 표시를 수행하거나 종속성에서 파일을 표시하는데 유용할 수 있습니다. 다음은 모든 `index.ts` 파일은 사이드 이펙트가 없는 것을 표시하는 예시입니다.\n\n```json\nrules: [\n  {\n    test: /\\/index.ts$/,\n    sideEffects: false,\n  },\n];\n```\n\n## imports, exports 문의 Type 한정자\n\n타입스크립트를 사용하는 경우 파일에서 타입을 가져오기 위해 파일을 가져오는 경우가 많습니다. 경우에 따라 출력 코드에 영향을 미치지 않는 타입에도 불구하고 실제로 해당 파일이 트리 쉐이킹 되지 않을 수 있습니다. 웹팩이 파일을 가져오고 사이드 이펙트가 있다고 판단할 경우, 유일하게 가져오는 것이 타입이더라도 \"used exports\" 최적화를 사용하지 않도록 설정하고 파일을 유지합니다.\n\n이 문제를 해결하는 한 가지 방법은 응용 프로그램에서 타입 가져오기 및 내보내기에 `type` 한정자를 사용하는 것입니다. [타입스크립트 문서](https://www.typescriptlang.org/docs/handbook/2/modules.html#typescript-specific-es-module-syntax)에서 다루며, 기본적으로 가져오기와 내보내기 키워드 뒤에 배치하여 명명된 모든 가져오기/내보내기가 타입이며 컴파일러에 의해 지워질 수 있음을 명시하는 수식어입니다. 이러한 모든 명령문이 삭제되면 번들러는 `import` 또는 `export`를 볼 수 없으므로 파일에 사이드 이펙트가 있는지 확인하지 않습니다. 최신 타입스크립트 버전(4.5+)에서는 전체 문이 아닌 개별 가져오기에서도 타입을 표시할 수 있습니다.\n\n예시입니다.\n\n```ts\n// TS 3.8+ syntax\nimport type { A, B, C } from \"./letters\";\n// TS 4.5+ syntax\nimport { type D, E } from \"./moreLetters\";\n// TS 3.8+ syntax\nexport type { F, G } from \"./letters\";\n// TS 4.5+ syntax\nexport { type H, I } from \"./moreLetters\";\n```\n\n#### 린터 규칙을 사용\n\n`@typescript-eslint/eslint-plugin` 패키지는 코드에서 자동으로 적용할 수 있는 두 가지 ESLint 규칙을 auto-fixer와 함께 제공합니다. `consistent-type-imports`는 가져오기 문의 타입 한정자를 처리하고, `consistent-type-exports`는 내보내기 문의 타입 한정자를 처리합니다. 이는 이러한 문제가 시간이 지남에 따라 코드로 다시 유입되는 것을 방지하고 신규 엔지니어가 프로세스에 투입되는데 도움이 됩니다.\n\n## Barrels\n\n배럴(Barrel) 파일은 자바스크립트 앱에서 일반적인 패턴이지만 예상치 못한 실수로 파일을 번들로 가져오기 쉽습니다. 배럴 파일은 다른 파일에서 내보내기를 다시 내보내는 파일입니다. 일반적으로 다음과 같은 와일드카드 내보내기를 사용합니다.\n\n```ts\nexport * from \"./someFile\";\nexport * from \"./someOtherFile\";\n```\n\n이렇게 하면 가져오기를 깔끔하게 유지하는 데 편리할 수 있지만, 다시 내보내는 파일 중 하나에 사이드 이펙트가 있을 경우 번들로 제공됩니다. 이 문제는 사용중인 가져오기가 다시 내보낸 파일에도 없는 경우에도 발생합니다.\n\n이 문제를 해결하는 한 가지 방법은 모든 배럴 파일에 `index.js` 또는 `index.ts`와 같이 쉽게 식별할 수 있는 이름을 지정하는 것입니다. 그런 다음 [이 글의 앞부분](#웹팩-규칙-사용)과 같은 웹팩 규칙을 사용하여 이러한 규칙에 대한 사이드 이펙트 탐지를 비활성화 할 수 있습니다. 타입스크립트 사용자의 경우 타입 한정자를 내보내기에 적용할 수 있으므로 와일드카드 내보내기 대신 명명된 내보내기를 사용하는 방법도 있습니다. 다음과 같은 방법입니다.\n\n```ts\nexport type { A, B, C } from \"./someFile\";\nexport { type D, E, F } from \"./someOtherFile\";\n```\n\n또한 이런한 방식은 배럴의 와일드카드 내보내기를 사용하면 실수로 중복 내보내기가 발생할 수 있는 것에 비해 정확성이 약간 향상됩니다. 명명된 내보내기를 명시적으로 내보내면 내부 파일 간에 사용되는 내보내기 대신 다른 패키지에 노출할 항목만 내보내므로 캡슐화가 개선됩니다.\n\n## 지연 로딩\n\n지연 로딩(Lazy loading)은 이 페이지에서 가장 효과적인 최적화가 될 가능성이 있지만, 제가 마지막으로 둔 이유가 있습니다. 지연 로딩은 훌륭한 도구이지만, 이 문서 전반에 걸쳐 언급된 다른 문제들로 가득 찬 코드에 의해 억제될 것입니다. 지연 로딩을 최대한 활용하려면 코드를 번들러에서 쉽게 분석하고 트리 쉐이킹 할 수 있어야 합니다.\n\n또한 지연 로딩은 잘 생각하지 않으면 오히려 더 많은 문제를 일으킬 수 있습니다. 프로세스가 시작될 때 사용자가 기다리고 있는 파일을 구문 분석하기 위해 코드를 로드하면 사전에 로드하는 것보다 사용자 환경이 나빠질 수 있습니다. 사용자 경험을 저해하지 않고 번들을 적절하게 분할하는 방식으로 앱을 분할할 수 있도록, 지연 로드가 일어날 위치를 생각하는 것이 중요합니다. 앞서 말한 단계를 수행하기 전에 지연 로딩을 설정한 경우, 이러한 부분이 지연 로딩에 적합한지 확인하는 것도 중요할 수 있습니다. 웹팩이 번들을 분할하도록 하기 위해 엔지니어가 코드의 많은 작은 세션들을 지연 로드하는 것이 일반적입니다. 위의 문제가 해결된 후에는 많은 수의 매우 작은 번들을 생성하게 됩니다.\n\n동적 가져오기 문 `import('./Module').then(module => {});`을 사용하여 자바스크립트 코드를 지연 로드할 수 있습니다. 이것은 프런트엔드 응용 프로그램의 라우터 수준에서 가장 잘 사용할 수 있습니다. 이 문은 프로미스 구문이므로 await을 사용하여 응답을 기다렸다가 일반적으로 모듈을 가져오는 것처럼 사용하거나 `.then()`의 콜백을 이용하여 가져온 모듈에 접근하여 사용할 수 있습니다.\n\n#### React Apps\n\n리액트 앱에서는 `React.lazy` 호출과 `Suspense` 컴포넌트를 함께 사용하여 컴포넌트의 지연 로딩을 쉽게 설정할 수 있습니다. 동적 가져오기 호출은 `React.lazy`로 묶은 다음 `Suspense` 컴포넌트 내에서 일반 컴포넌트로 사용할 수 있습니다. 예를 들면 다음과 같습니다.\n\n```tsx\nconst LazyViewer = React.lazy(() => import(\"./Viewer\"));\n\nconst App = () => (\n  <Suspense fallback={<Spinner />}>\n    <LazyViewer />\n  </Suspense>\n);\n```\n\n이러한 기능은 사용자 입력이 필요한 상황에서만 이상적으로 사용해야 하며, 그렇지 않으면 응용프로그램 전체의 많은 로드 상태로 인해 사용자 경험이 저하될 수 있습니다. 좋은 예시 중 하나는 모달 또는 대화 상자 내부입니다. 기본 컴포넌트는 초기에 로드되지만 `React.lazy` 컴포넌트는 모달/대화 상자가 열 때까지 렌더링 되지 않습니다. `React.lazy`에 대한 [자세한 내용은 React Docs](https://reactjs.org/docs/code-splitting.html#reactlazy)에서 확인할 수 있습니다.\n\n#### 프리페치 및 프리로드\n\n웹팩을 사용하면 상위 번들이 로드된 후 지연 로드된 번들을 미리 가져올 수 있는 힌트를 제공할 수 있습니다. 이 작업은 동적 가져오기 문의 경로 앞에 `/* webpackPrefetch: true */`를 추가하여 수행할 수 있습니다. 상위 번들이 로드된 이후가 아닌 함께 로드하기 위해 `/* webpackPreload: true */`를 추가할 수 있습니다. 그러나 이 작업은 브라우저가 유휴 상태가 아닌 중간 우선 순위로 다운로드 되므로 과도하게 사용할 경우 프리페치 대신 프리로드을 사용하는 것이 좋지 않을 수 있습니다. 이것은 페이지 로드에 필요한 다른 자산 또는 번들보다 우선처리 되기 때문입니다.\n\n프리페치와 프리로드를 모두 사용하는 가져오기의 예시는 `import(/* webpackPrefetch: true */ /* webpackPreload: true */ './Module').then(module => {});`입니다. 이러한 힌트에 대한 자세한 내용은 [웹팩 설명서](https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules)에서 확인할 수 있습니다.\n\n## 결론\n\n웹 앱의 번들 크기를 개선하기 위해 할 수 있는 일은 매우 많습니다. 이 글은 여러분에게 한번에 많은 것을 던져주는 것처럼 보일 수 있지만, 제 목표는 여러분이 번들러와 옵티마이저가 실제로 무엇을 하는지, 일반적인 함정이 어떻게 발생하는지 더 잘 이해할 수 있도록 도움을 주는 것입니다. 이러한 제안은 대부분 사이트에서 강력하게 도움이 될 것이지만, 이 글에서 트리 쉐이킹이 실패할 수 있는 방법에 대한 학습은 프로젝트에서 추가적인 개선점을 찾는 데 도움이 될 것입니다.\n\n저는 이 사이트, 몇 개의 다른 개인 프로젝트 사이트 및 작업 중인 프로젝트를 크게 최적화하기 위해 이러한 방법을 성공적으로 사용했습니다. 제가 자바스크립트 생태계에서 새로운 것을 발견하거나 변화가 생긴다면, 이 글을 업데이트 하겠습니다.\n",
      "short_description": "원문 : https&#x3A;//madelinemiller.dev/blog/reduce-webapp-bundle-size/웹팩과 같은 웹 번들러는 웹 앱을 배포하는 데 유용한 도구이지만, 더 복잡한 프로그램의 경우 번들 크기가 문제가 될 수 있습니다. 근본적인 문제와 ",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/lky5697/post/3ed44a50-fd24-4069-b616-83757adeb388/image.avif",
      "comments_count": 3,
      "url_slug": "reduce-webapp-bundle-size",
      "likes": 27,
      "liked": false,
      "user": {
        "id": "82879acb-032e-4f14-a5cd-33af957c8030",
        "username": "lky5697",
        "profile": {
          "id": "a107af57-0d16-44a3-9419-c34702d14da3",
          "display_name": "강엽이",
          "thumbnail": "https://velog.velcdn.com/images/lky5697/profile/403b47b6-c5fb-4ca5-8c1c-86a4ebf19939/image.png",
          "short_bio": "FE Engineer ",
          "profile_links": {},
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": null,
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [
        {
          "id": "794ede2c-f65b-4035-b0fb-d7ad2ee638fa",
          "user": {
            "id": "5db37633-a059-4d1d-b204-9e6aa43e9b55",
            "username": "namu1105",
            "profile": {
              "id": "21e83c98-b9a7-468e-9bda-8f6a52ce5113",
              "thumbnail": "https://images.velog.io/images/namu1105/profile/9b8bec48-dd06-404b-b845-7bece0c08eab/social.png",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "잘 읽었습니다!",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-01-28T18:34:19.818Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "c9b36d6a-d418-47ef-bd41-065d1be4725c",
          "user": {
            "id": "3c7dfd77-9ace-4783-a5c7-1f137e457497",
            "username": "sam_532",
            "profile": {
              "id": "9f492c63-4abe-4c67-bda0-9eb2f77c209a",
              "thumbnail": null,
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "   Same issue here and i cant find any solutions\n",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-01-30T10:43:12.547Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "6193e613-ea7a-462a-b197-24a403ce7924",
          "user": {
            "id": "0a60e8bf-0574-4ebc-8dc5-05a545f55dfe",
            "username": "youngxpepp",
            "profile": {
              "id": "0ac3e00f-e3fd-4655-bc2e-bbd7449e8db8",
              "thumbnail": "https://velog.velcdn.com/images/youngxpepp/profile/e96565a9-17f5-46e4-87be-d6b6a0491b7a/image.JPG",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "잘 읽었습니다! 덕분에 웹앱 번들 크기를 줄일 수 있었어요!",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-01-31T08:09:40.918Z",
          "deleted": false,
          "__typename": "Comment"
        }
      ],
      "series": null,
      "linked_posts": {
        "previous": {
          "id": "6f084286-2b9c-483b-9928-d5bf81012c27",
          "title": "(번역)더 좋은 타입스크립트 프로그래머로 만드는 11가지 팁",
          "url_slug": "11-tips-that-help-you-become-a-better-typescript-programmer",
          "user": {
            "id": "82879acb-032e-4f14-a5cd-33af957c8030",
            "username": "lky5697",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": {
          "id": "f1d21c92-2863-4c51-b4aa-8eea0231a726",
          "title": "(번역) HTML 이미지 최적화",
          "url_slug": "fast-images",
          "user": {
            "id": "82879acb-032e-4f14-a5cd-33af957c8030",
            "username": "lky5697",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "c3fc002e-cf43-4bf9-b22e-14973fe8a9ad",
      "title": "[JS] DOM이 뭔가요?",
      "released_at": "2023-03-07T06:36:59.467Z",
      "updated_at": "2023-03-20T09:19:20.468Z",
      "tags": [
        "JavaScript",
        "TIL",
        "html"
      ],
      "body": "자바스크립트에서 HTML의 요소들을 조작(CRUD)하려면 그 전에 DOM이 무엇인지 알아야 한다.\n\n# DOM\n\n`DOM`은 Document Object Model로 **HTML 문서의 계층적 구조와 정보**를 표현하며 이를 제어할 수 있는 **API를 제공**하는 **트리 자료구조**다. 이때, API란 DOM이 제공하는 **프로퍼티와 메서드**를 말한다.\n\n<br />\n\n## HTML 요소와 노드 객체\n\n`HTML 요소`는 HTML 문서를 구성하는 개별적인 요소를 말한다. 즉, HTML의 `div`나 `span` 등이 HTML 요소가 된다.\n\nHTML 문서는 HTML 요소들의 집합으로 이뤄져 있으며, HTML 요소는 중첩 관계를 갖는다. 이때 요소 간에는 중첩 관계에 의해 계층적인 `부모와 자식 관계`가 형성된다. \n\n<br />\n\nHTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 `요소 노드 객체`로 변환된다. 이때 요소의 태그(div, span 등)는 `요소 노드`, 어트리뷰트(class, id 등)는 `어트리뷰트 노드`로, 텍스트 콘텐츠는 `텍스트 노드`로 변환된다.\n\n이때 HTML 요소 간 부모와 자식 관계를 반영하여 HTML 요소를 객체화한 **모든 노드 객체들을 트리 자료 구조**로 구성한다.\n\n<br />\n\n## 노드의 객체 타입\n\n노드 객체는 종류가 있고 상속 구조를 가지며 총 12개의 노트 타입이 있다.\n\n다음은 대표적인 노드 타입이다.\n\n1. 문서 노드\n    - DOM 트리 최상위에 존재하는 루트 노드로서 `document 객체`를 가리킴\n    - 브라우저가 렌더링한 `HTML 문서 전체`를 가리키는 객체\n    - 전역 객체 `window`의 `document` 프로퍼티에 바인딩 되어 있음\n    - 브라우저 환경의 **모든 자바스크립트 코드는** 전역 객체 window의 document 프로퍼티에 바인딩된 **하나의 document 객체를 가리킴** (문서 당 document 객체는 **유일**함)\n    - DOM 트리의 루트 노드기 때문에 **트리의 노드(하위 노드)들에 접근하기 위한 진입점 역할**을 함\n2. 요소 노드\n    - `HTML 요소`를 가리키는 객체\n    - HTML 요소 간 중첩에 의해 `부모-자식 관계`를 가지고 이를 통해 정보를 구조화\n    - 문서의 구조를 표현함\n3. 어트리뷰트 노드\n    - HTML 요소의 `어트리뷰트`를 가리키는 객체\n    - **어트리뷰트가 지정된 HTML 요소의 요소 노드**와 연결되어 있음\n    - 부모 노드가 없기 때문에 **요소 노드의 형제 노드는 아님** (부모를 공유하지 않음)\n    - 먼저 요소 노드에 접근해야 어트리뷰트 노드에 접근할 수 있다.\n4. 텍스트 노드\n    - HTML 요소의 `텍스트`를 가리키는 객체\n    - 문서의 `정보`를 표현하는 역할\n    - `요소 노드의 자식 노드`이며 자식 노드를 가질 수 없는 `리프 노드`\n    - 먼저 부모 노드인 요소 노드에 접근해야 텍스트 노드에 접근할 수 있음\n\n<br />\n\n이 외에도 주석을 위한 `Comment` 노드, 복수의 노드를 생성하여 추가할 때 사용하는 `DocumentFragment` 노드 등 총 12가지 타입이 있다.\n\n<br />\n\n### body 내부의 요소 노드, 어트리뷰트 노드, 텍스트 노드 확인해 보기\n\n다음처럼 트리 구조를 이루는 HTML 문서를 작성한 다음, body 내부의 요소 노드/어트리뷰트 노드/텍스트 노드를 확인해 보았다.\n![](https://velog.velcdn.com/images/jhsung23/post/a59304c4-fefb-48d2-8e87-39f28f65681d/image.png)\n\n\n1. 요소 노드\n\n예시로 HTML 문서에서 (렌더링 엔진을 거쳐 생성될) DOM에는 어떤 것들이 있을지 살펴보자.\n\n다음과 같이 HTML 문서를 작성하고 live server로 크롬 브라우저에 열어 보았다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1 id=\"subject\" class=\"title-text\">노드의 객체 타입</h1>\n    <div id=\"description\" class=\"text\">대표적인 노드의 객체 타입</div>\n    <ul>\n      <li>문서 노드</li>\n      <li>요소 노드</li>\n      <li>어트리뷰트 노드</li>\n      <li>텍스트 노드</li>\n    </ul>\n  </body>\n</html>\n```\n\n<br />\n\nbody 내부만 살펴봤을 때 body의 자식이 될 노드는 [h1 요소 노드, div 요소 노드, ul 요소 노드] 이렇게 3가지가 나올 것이라 예상했다.\n\n<br />\n\n특정 노드의 자식 노드들을 참조할 수 있는 `childNodes`로 자식 노드들을 출력해보았다.\n\n실제로 출력해 봤을 땐 *예상과 달리 11개의 자식 노드가 나타났다*.\n\n![](https://velog.velcdn.com/images/jhsung23/post/b05e0dc1-98fa-48c0-8dcb-ebd712d5e72b/image.png)\n\n<br />\n\n`h1`, `div`, `ul`은 예상했던 노드지만 `text`, `comment`, `script`는 파일에 작성하지 않았는데 자식 노드로 들어가 있어서 무엇인가 했더니, `text`의 경우 **HTML 요소 사이의 개행이나 공백은 텍스트 노드**가 되어 `text`가 된다고 한다.\n\n즉, 다음과 같이 아무것도 없다고 생각한 부분이 `text` 노드로 변경된 것이다.\n\n```html\n<body>\n  <!-- text 노드 -->\n  <h1 id=\"subject\" class=\"title-text\">노드의 객체 타입</h1>\n\t<!-- text 노드 -->\n  <div id=\"description\" class=\"text\">대표적인 노드의 객체 타입</div>\n\t<!-- text 노드 -->\n  <ul>\n    <li>문서 노드</li>\n    <li>요소 노드</li>\n    <li>어트리뷰트 노드</li>\n    <li>텍스트 노드</li>\n  </ul>\n\t<!-- text 노드 -->\n\t<!-- comment 노드 -->\n\t<!-- text 노드 -->\n\t<!-- script 노드 -->\n\t<!-- text 노드 -->\n</body>\n```\n\n> `공백 텍스트 노드`: HTML 요소 사이의 개행이나 공백은 텍스트 노드(text)가 된다.\n> \n\n<br />\n\ntext 노드의 정체는 알게 됐고, 그렇다면 `comment`와 `script` 노드의 정체는 무엇일까 하고 요소 창을 열어 봤더니\n\n![](https://velog.velcdn.com/images/jhsung23/post/be5c355c-629e-4460-924c-6e3aea3aa0cd/image.png)\n\n`live server`에 의해 **자동적으로 생성된 주석과 자바스크립트 코드가 노드로 생성된 것**이었다. 😅\n\n<br />\n\n2. 어트리뷰트 노드\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1 id=\"subject\" class=\"title-text\">노드의 객체 타입</h1>\n    <div id=\"description\" class=\"text\">대표적인 노드의 객체 타입</div>\n    <ul>\n      <li>문서 노드</li>\n      <li>요소 노드</li>\n      <li>어트리뷰트 노드</li>\n      <li>텍스트 노드</li>\n    </ul>\n  </body>\n</html>\n```\n\n어트리뷰트를 가지고 있는 노드는 `h1`과, `div` 뿐이다. 이 요소 노드에 연결되어 있는 어트리뷰트 노드는 `attributes` 프로퍼티로 확인할 수 있다. 이는 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴 `NamedNodeMap` 객체를 반환한다.\n\n<br />\n\n두 요소 노드의 어트리뷰트를 조회해 봤더니, 다음과 같이 출력됐다. 두 객체의 length는 2로, 두 개의 어트리뷰트를 갖고 있음을 의미한다.\n\n![](https://velog.velcdn.com/images/jhsung23/post/ea1c7fea-e8ce-46ca-a967-526e8672fb19/image.png)\n\n<br />\n\n또한, 어트리뷰트 노드는 부모 노드가 없기 때문에 요소 노드와 연결은 되어 있지만 형제 노드가 아니라고 했다. 이를 확인하기 위해 어트리뷰트 노드의 부모 노드와 형제 노드를 확인해 보았다.\n\n![](https://velog.velcdn.com/images/jhsung23/post/8f17a100-3c13-4396-9b75-af462e0f024d/image.png)\n\n어트리뷰트 노드는 `parentNode`도 없고(null) `sibling 노드`도 없어(null) 요소 노드와 형제 관계가 아님을 알 수 있었다.\n\n<br />\n\n3. 텍스트 노드\n\nul 내부의 li 텍스트 요소를 출력해 보자.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <h1 id=\"subject\" class=\"title-text\">노드의 객체 타입</h1>\n    <div id=\"description\" class=\"text\">대표적인 노드의 객체 타입</div>\n    <ul>\n      <li>문서 노드</li>\n      <li>요소 노드</li>\n      <li>어트리뷰트 노드</li>\n      <li>텍스트 노드</li>\n    </ul>\n  </body>\n</html>\n```\n\n<br />\n\n`document(문서 노드)`에서 li 요소의 요소 노드를 모두 가져와 순차적으로 접근하면서 li의 첫 번째 자식인 `text 노드`의 `nodeValue`를 참조해 출력하였다.\n\n![](https://velog.velcdn.com/images/jhsung23/post/7b0c6936-814a-47c9-a132-ef4a7e5af81b/image.png)\n\n> `firstChild`: 노드의 첫 번째 자식 노드 참조\n`nodeValue`: text 노드의 값 참조 (문서 또는 요소 노드에서 참조 시 null 리턴)\n> \n\n<br />\n\n이제 DOM이 무엇인지 감을 잡았으니! 다음 글은 CRUD에 대해 작성해봐야 겠다.",
      "short_description": "DOM은 문서 객체 모델, 문서 객체 모델은?",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/jhsung23/post/a59304c4-fefb-48d2-8e87-39f28f65681d/image.png",
      "comments_count": 0,
      "url_slug": "JS-DOM이-뭔가요",
      "likes": 1,
      "liked": false,
      "user": {
        "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
        "username": "jhsung23",
        "profile": {
          "id": "3860fe22-b926-4d33-889b-9d99b39c3aa8",
          "display_name": "초코침",
          "thumbnail": "https://velog.velcdn.com/images/jhsung23/profile/bdc37989-65a0-42d5-899a-20fe668a3265/image.jpg",
          "short_bio": "",
          "profile_links": {},
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "chococheem.log",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": {
        "id": "e93e642e-3f44-499c-88ef-8391110a1fb8",
        "name": "TIL",
        "url_slug": "TIL",
        "series_posts": [
          {
            "id": "207d3569-8d03-4d36-9c9d-06f1523e5cd1",
            "post": {
              "id": "7efe4763-21c8-4e33-a231-a87c21a59a8c",
              "title": "[HTML] HTML 기초",
              "url_slug": "TIL-HTML-기초",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "578208b8-6d6a-409e-aee9-84cd3cd9ba8a",
            "post": {
              "id": "339b4467-151b-4faa-a465-da83e4c6b5d0",
              "title": "[CSS] CSS 기초",
              "url_slug": "TIL-CSS-기초-1sth92z2",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "80c4f954-dfd2-4c69-9152-12f2f0378465",
            "post": {
              "id": "31e3c88d-6053-4ba2-b87d-556e20f20525",
              "title": "[CSS] flex (1)",
              "url_slug": "TIL-CSS-flex",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "7ca73a24-8307-4197-b6ac-703012d834f6",
            "post": {
              "id": "ac059242-86c4-45dc-bd11-abd45210f8d1",
              "title": "[CSS] flex (2)",
              "url_slug": "TIL-CSS-flex-2",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "f1afb412-581f-4ff8-bff9-a3a943d448a4",
            "post": {
              "id": "1d3a02ca-2815-49d8-8f6a-27718f1bab7b",
              "title": "[CSS] Mac 계산기 클론하기",
              "url_slug": "TIL-Mac-계산기-클론하기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "ba8880a7-fd53-48d7-8ed8-b761171f87ae",
            "post": {
              "id": "0ea546f0-a1e9-4c0f-aea2-252eb9c9aabd",
              "title": "[CSS] Grid",
              "url_slug": "CSS-Grid",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "33e7b251-9a0e-42fe-b9ce-f6117f208e4b",
            "post": {
              "id": "34fe625f-8941-45bd-a0ab-87a010c9dfdb",
              "title": "[JS] slice와 splice",
              "url_slug": "JS-slice와-splice",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "9477a03c-6745-40c2-a4ae-fd06fc57a935",
            "post": {
              "id": "cb6a91f4-8a84-4f43-b7b3-61fa94d298c8",
              "title": "[JS] 함수를 정의하는 방법",
              "url_slug": "JS-함수를-정의하는-방법",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "40bbf872-5910-4e9c-ab57-19f74cd8a6c6",
            "post": {
              "id": "59ef76e1-0f5a-4234-badd-48b11177c9e2",
              "title": "[JS] 순열(Permutation) 구현하기",
              "url_slug": "JS-순열Permutation-구현하기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "44efc6fc-412f-493e-8f89-f4558494e823",
            "post": {
              "id": "6b12978c-2981-420e-a76c-1d2a204c4521",
              "title": "[JS] 문자열에서 특정 위치의 문자를 변경하고 싶은 경우",
              "url_slug": "JS-문자열에서-특정-위치의-문자를-변경하고-싶은-경우",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "d85a2918-9356-4d1a-b8c6-0be24b9ce810",
            "post": {
              "id": "d5589afb-9644-4653-8444-c16e3a883c09",
              "title": "[JS] let과 const",
              "url_slug": "JS-let과-const",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "700fc0f4-3e76-4673-a1a8-163b7b711e20",
            "post": {
              "id": "7a09ebe5-9fea-4db6-87f4-15f761a8027f",
              "title": "nvm 설치하기",
              "url_slug": "nvm-설치하기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "ff4b0f31-00e4-407b-a5b1-2046e0b90db3",
            "post": {
              "id": "606aff56-939c-438e-a1df-5bfc06b649da",
              "title": "[JS] 요소 노드의 텍스트 조작하기(nodeValue, textContent, innerHTML)",
              "url_slug": "JS-요소-노드의-텍스트-조작하기nodeValue-textContent-innerHTML",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "f0f4bdf1-1108-43a0-a144-08f6aaee8254",
            "post": {
              "id": "685ea9cd-d70d-42a7-8e17-2978fb048712",
              "title": "[JS] 자바스크립트의 배열은 배열이 아니다!",
              "url_slug": "JS-자바스크립트의-배열은-배열이-아니다",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "b20859eb-1b61-41c4-ae02-0581ef4395e2",
            "post": {
              "id": "e74a519a-0183-47c9-87ae-51e832e5765f",
              "title": "[JS] JSON 다루기(JSON.parse(), JSON.stringify())",
              "url_slug": "JS-JSON-다루기JSON.parse-JSON.stringify",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "8a365a7b-decf-44c4-bc3f-02f3856ae8dd",
            "post": {
              "id": "ea9a3b86-01b0-42ff-aa27-8f6bebd34b1c",
              "title": "[JS] 원시 자료형과 참조 자료형",
              "url_slug": "JS-원시-자료형과-참조-자료형",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "58ffb928-46fc-4591-b2eb-413c07007401",
            "post": {
              "id": "750767b6-5ea0-49f1-ac6d-a4cad449c982",
              "title": "[JS] []===[]는 왜 false인가",
              "url_slug": "JS-는-왜-false인가",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "894baae4-f80d-4df7-a9b9-e2ccf011c1b2",
            "post": {
              "id": "43801fc1-216d-4a96-84db-9fe92788efbd",
              "title": "[JS] this (동적 바인딩)",
              "url_slug": "JS-this-동적-바인딩",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "120cd8c0-9891-4e70-a5bf-058d0e8286bb",
            "post": {
              "id": "d3d787f5-7e7e-4d8a-8560-c032171bccbd",
              "title": "[VanillaJS] 유효성 검사를 포함한 간단한 회원가입 폼 페이지 만들기",
              "url_slug": "VanillaJS-유효성-검사를-포함한-간단한-회원가입-폼-페이지-만들기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "0f13eedb-215a-485f-a470-f0c58d55f23d",
            "post": {
              "id": "25fc2754-d467-428b-8eb7-e7a1be31d1b7",
              "title": "#fff와 #ffffff는 무슨 차이인가요?",
              "url_slug": "fff와-ffffff는-무슨-차이인가요",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "bc3832a7-5eeb-4efa-bb30-07ae050b6270",
            "post": {
              "id": "2493c21e-75cf-42ac-a683-8edae92548e0",
              "title": "[JS] 안다고 생각했지만, 헷갈렸던 문법들",
              "url_slug": "JS-안다고-생각했지만-헷갈렸던-문법들",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "1a9faf51-f2c7-4e7a-b21c-c0ab3986931d",
            "post": {
              "id": "c3fc002e-cf43-4bf9-b22e-14973fe8a9ad",
              "title": "[JS] DOM이 뭔가요?",
              "url_slug": "JS-DOM이-뭔가요",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "5013e406-bf2b-4d04-95e8-0fb1cc25ac5e",
            "post": {
              "id": "bbe88e26-2110-45f5-9976-9fc966279f6a",
              "title": "[VanillaJS] 영화관 좌석 예약 페이지 만들기",
              "url_slug": "VanillaJS-영화관-좌석-예약-페이지-만들기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "4dcd707a-65ab-4a98-9af9-16fda5f9198c",
            "post": {
              "id": "e35996f3-defc-473f-b292-61cddbc2c9e3",
              "title": "[CSS] 테두리가 두 줄처럼 보이는 경우 (border)",
              "url_slug": "CSS-테두리가-두-줄처럼-보이는-경우-border",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "0d373f3e-1003-4b3e-9ef2-c4fd50c4e446",
            "post": {
              "id": "f8eb6410-d5f8-4e9f-87b8-43c420ed340a",
              "title": "[JS] ISO 형식의 날짜(yyyy-mm-ddThh:mm:ssZ)를 현재 위치 시간대로 변경하기",
              "url_slug": "JS-ISO-형식의-날짜yyyy-mm-ddThhmmssZ를-현재-위치-시간대로-변경하기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "701d781f-5dd5-4146-aa54-bd29052af5b5",
            "post": {
              "id": "3eed07da-4b97-4508-8c9f-322571585152",
              "title": "[VanillaJS] 간단한 페이지네이션 구현하기",
              "url_slug": "VanillaJS-페이지네이션-구현하기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "740774d8-2de9-42f6-9fd1-25ceb43ca292",
            "post": {
              "id": "0ef6c9bc-1ff8-49de-adb6-baaad8371f6e",
              "title": "[HTML] 브라우저의 렌더링 과정",
              "url_slug": "HTML-브라우저의-렌더링-과정-iv8dq4cv",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "15daf6cf-8e5f-4cb9-8c6d-7cd72b5ad2c8",
            "post": {
              "id": "5fd259c6-c673-4116-906a-ca8a1ccfdee4",
              "title": "[JS] preventDefault로 기본 동작 중단시키기",
              "url_slug": "JS-preventDefault로-기본-동작-중단시키기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "b9683302-48e0-46a5-8f09-fa795ee77e0c",
            "post": {
              "id": "9915869f-34ff-4d4a-9bda-b480993be2d8",
              "title": "[JS] 클래스 - 자바스크립트에 클래스 없다며",
              "url_slug": "JS-자바스크립트에-클래스-없다며",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "aa02adcc-9337-4ba1-8747-dbe242ddef07",
            "post": {
              "id": "fd770793-c29d-4d52-8e16-71942d081ff3",
              "title": "OOP 객체 지향 프로그래밍",
              "url_slug": "OOP-객체-지향-프로그래밍",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "a0a27839-4aa0-426d-b4e4-9c7109c07c44",
            "post": {
              "id": "f65aaa2a-d84b-43e4-b027-ea1936ac2aab",
              "title": "[JS] 프로토타입 이해하기 - 프로토타입은 나의 부모",
              "url_slug": "JS-프로토타입-이해하기-프로토타입은-나의-부모",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "f8eb29f7-104a-4ee2-98db-79b7512c0cef",
            "post": {
              "id": "5fcbf33e-dc2c-4b4b-825e-21edbb12c4f9",
              "title": "[JS] 프로토타입 체인 이해하기",
              "url_slug": "JS-프로토타입-체인-이해하기",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "cfee0906-28c5-47a0-886e-370bc242ce17",
            "post": {
              "id": "5c7c0f55-f46b-46e8-a270-7f31ce8bd45f",
              "title": "[JS] Promise - 책임감있는 비동기 처리",
              "url_slug": "JS-Promise-책임감있는-비동기-처리",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "02814fad-1653-4900-bbab-0a9adc3719e0",
            "post": {
              "id": "9c201b2d-a65e-4868-8494-582b7e7c9ba6",
              "title": "[JS] setTimeout을 연속적으로 실행시켰을 때의 순서",
              "url_slug": "JS-setTimeout을-연속적으로-실행시켰을-때의-순서",
              "user": {
                "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
                "username": "jhsung23",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": {
          "id": "2493c21e-75cf-42ac-a683-8edae92548e0",
          "title": "[JS] 안다고 생각했지만, 헷갈렸던 문법들",
          "url_slug": "JS-안다고-생각했지만-헷갈렸던-문법들",
          "user": {
            "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
            "username": "jhsung23",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": {
          "id": "bbe88e26-2110-45f5-9976-9fc966279f6a",
          "title": "[VanillaJS] 영화관 좌석 예약 페이지 만들기",
          "url_slug": "VanillaJS-영화관-좌석-예약-페이지-만들기",
          "user": {
            "id": "a79ab9eb-1b82-40ec-9482-0f777a20df60",
            "username": "jhsung23",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "e8494ddc-125d-47d9-81cb-881a42be97e2",
      "title": "새로운 기회를 향한 이동 (교보문고 리드잇 6호 기고글)",
      "released_at": "2023-02-06T23:48:20.505Z",
      "updated_at": "2023-03-20T00:50:47.756Z",
      "tags": [
        "교보문고",
        "리드잇"
      ],
      "body": "> 교보문고에서 발간하는 리드잇zine 6호에 회사를 나와서 창업에 기웃거리다 다시 취직을 했던 2019년도 저의 이야기를 기고해 보았어요. 담당자분께 여쭈어보니 블로그에 올려도 괜찮다고 하더라구요. 아래 원고를 공유합니다. \n \n# 회사와 창업 사이에서 1년\n\n마산과 부산 사이에는 내가 잠시 머물렀던 진해 바닷가 마을이 있다. 명절에 내려와 이 마을을 지날 때면 왠지 모르게 마음이 아린다. 나는 2018년 12월에 창원에서 다니던 회사를 그만두었다. 이직을 위한 것이 아니라 그냥 좀 쉬고 싶었고 어렴풋하게 창업이란 것을 해보고 싶었다. 그와 동시에 진해 바닷가 마을의 새 아파트로 이사도 하게 되었다. 그곳은 바닷가 근처라 아침이면 해안가 조깅을 할 수 있었고 정말 한적한, 내가 너무 좋아하는 분위기의 마을이었다. 내가 마을이라 표현해 시골이란 느낌도 들지만 새 아파트들이 들어선 어촌 마을의 느낌이라고 할까?\n\n![](https://velog.velcdn.com/images/joosing/post/c7651bb1-41c2-4758-a04e-a1d73afeed43/image.png)\n\n\n# 회사를 그만두다\n\n6년 조금 넘게 근무한 나의 2번째 회사는 소프트웨어 개발자들이 흔히 꿈꾸는 자유로운 문화의 회사는 아니었다. 400여명의 직원 중 소프트웨어 개발자는 15명 정도였고 8시 출근 17시 퇴근에 19시 30분까지 잔업이라는 특이한 문화(선택적이었지만 대부분 정규 근무시간처럼 지켰다)를 가지고 있었다. R&D 센터 건물에는 10시, 3시에 휴식시간을 알리는 종이 울렸는데 휴식 시간에 웬만하면 쉬도록 권고하기도 했다. 회사에서 답답한 점도 있었지만 크게 성장할 수 있는 발판이 되었던 것도 사실이다. 내 연차에 맡기 힘든 대규모 프로젝트 메인 개발자로 일해 보기도 했고, 전체 시스템을 처음부터 끝까지 만들어 보며 소프트웨어 개발 프로세스를 주도적으로 수행해 볼 기회도 있었다. 회사를 그만둔 가장 큰 이유는 일하면서 내 자아가 죽어 있는 것 같은 느낌을 지속해서 받았기 때문이다. 능동적으로 문제를 찾고 해결하기를 좋아하는 내 성향이 벽을 많이 만난 것 같고, 누군가의 진짜 문제를 해결하고 싶은 욕구가 여러 제약 아래에서 차단되었던 것 같다. 나는 세상에 도움이 되는 가치를 능동적으로 만들고 싶다는 생각을 자주 했다.\n\n# 1달 생활비 X 12개월\n\n일단 이직에 대한 생각을 하지 않고 회사를 그만 두었다. 그때 당시에 네트워크 패킷을 캡처해서 분석하는 일에 꽂혀 있었는데 막연히 이 분야와 관련된 창업을 해보고 싶다는 생각을 했다. 8년 정도 일하며 한 번도 쉰 적이 없어서 충분히 쉬고 싶기도 했다. 지금 생각하면 정말 대책 없이 회사를 그만두었는데 그냥 1달 생활비 곱하기 12개월 생활비를 모아두고 회사를 그만두었다. \n\n# 인생 첫 자유\n\n8년 만에 회사를 그만두고 나니 너무 좋았다. 바닷가 마을에서 아침이면 일어나 조깅을 했고, 진해의 도서관을 돌아다니며 책을 보고, 동네를 걸으며 아무 카페나 들어가 여유로운 시간을 보내기도 했다. 한 가지 아쉬운 점은 경제적인 불안감이 있어서 멀리 여행을 가지 못했다는 것이다. 그래도 소소한 일상에서의 행복이 워낙 컸던 터라 큰 아쉬움은 없었다. 진해의 용원 도서관이라는 곳에 매일 출근 아닌 출근을 했는데 멀쩡한 도로를 두고 멀리멀리 돌아 해안도로를 따라 출근을 했다. 그때 당시 자동차 창문을 열어 젖히고 잔나비의 신나는 음악을 틀고 바닷가 도로를 달리던 너무 행복했던 기억을 잊을 수 없다. 아무런 제약도 아무런 스트레스도 없었다. 완전한 자유였다. 돌아보면 내 기억이 있는 초등학교 시절부터 대학교, 그리고 직장인이 되기까지 이런 자유를 누렸던 적이 한 번도 없었던 것 같다. 학생 때는 공부를 잘하고 싶은데 공부가 어려워 늘 불편했고 대학생 때는 프로그래밍 실력을 키워야 한다는 생각에 잠시도 편안히 있어 본 적이 없는 것 같다. 35년 만에 내 인생 첫 자유라고 해도 과언이 아닌 시간이 주어졌다. 너무 행복했다.\n\n# 세상에 가치를 만들고 싶어\n\n첫 세 달 정도는 아무 생각 없이 쉬었던 것 같다. 그리고 이제 뭔가 좀 만들어 봐야겠다는 생각이 들었다. 앞서 잠깐 언급했지만 나의 막연한 창업 아이템은 네트워크 패킷을 Wireshark 라는 프로그램이 캡처해 주면 애플리케이션에 따라 다르게 정의되는 메시지를 분석해서 구조화된 정보로 사용자에게 보여주는 것이었다. 뿐만 아니라 메시지의 특정 요소들만 필요에 따라 필터링 할 수 있어 메시징 처리 시스템 간에 통신 문제가 생겼을 때 원인을 찾기 용이했다. 이걸 원래 Lua Script라는 언어로 개발해서 Wireshark에 플러그인으로 설치해야 했는데 사용자가 GUI 상에서 메시지 구조 정보를 입력하면 Lua Script 코드를 자동 완성해 주는 서비스를 만들어 보겠다는 아이디어였다. 뿐만 아니라 실제 애플리케이션 소스코드에 메시지를 정의하는 코드 또한 자동 생성할 수도 있다고 생각했고 (그때 당시 C, C++을 생각함) 인터페이스 스펙을 명시한 문서도 함께 자동으로 생성할 수 있겠다고 생각했다. 그래서 사용자가 GUI에서 메시지 정보를 한 번만 입력하면 코드, 문서 그리고 메시지 분석 스크립트까지 All-in-one으로 생성하고 관리한다는 컨셉이었다. 그렇게 되면 개발자가 직접 디버깅 인프라를 개발하는 대신 만들어진 인프라를 안정적으로 사용하기만 하면 되었다. 뿐만아니라 코드와 문서, 분석 스크립트 간의 동기화 문제도 자연스레 해결되어 무척 편리하겠다고 생각했다. 사실 이런 아이디어를 낸 이유는 이전 직장에서 매우 유용하게 사용하기도 했고 다른 회사 개발자들이 이 기능을 신기해 하면서 잘 활용하지 못하고 있었기 때문이었다. \n\n# 어떻게 생존할 것인가?\n\n분명 나에게 필요한 서비스였고, 나와 함께 한 많은 개발자들에게 필요한 서비스라고 생각했다. 드디어 세상에 도움이 되는 일을 능동적으로 할 수 있는 내가 꿈꾸던 일이었다. 그런데 막상 창업을 한다고 생각하니 서비스를 만들기 전에 이런 생각부터 들었다. 이 서비스가 만들어졌다고 가정하고 누구에게 얼마에 팔면 내가 지속적으로 생존(경제적으로)할 수 있을까? 일단 방위산업 분야에서 클라우드 서비스는 상상도 못할 일이고, 설치형 라이선스를 판매한다고 가정하면 라이선스 하나에 10만원이면 한달에 10개를 팔아야 100만원인데 한달에 10명의 고객이 구매할까? 서비스의 특징을 생각해보면 Visual Studio 같은 IDE와 달리 개발자 한 사람이 매일 사용해야 하는 서비스가 아니었다. 통신 인터페이스가 정의되면 처음에 한 번 사용하고 인터페이스가 바뀔 때만 수정해 주면 되는 컨셉이라 회사마다(후하게 생각해도 팀마다) 한개의 라이선스만 사서 공유해서 사용하면 되는 일이었다. 그러면 10개라는 단위는 개인이 아니라 회사가 될 것인데 이 좁은 분야에서 지속적으로 수익이 날지 의문이었다. 그럼 100만원에 파는 건 어떤가? 분명 편리하긴 한데 앞서 설명했지만 매일 사용하는 서비스가 아니었고 이 서비스의 도움이 없더라도 개발자가 Lua Script 언어를 배우고 시간을 내어 직접 작성할 수도 있었기 때문에 100만원이라는 가격에는 물음표가 생겼다. 10만원 이하라면 개발자 개인이 자신의 귀찮은 일을 대신해 주길 기대하며 구매해서 사용할 것 같았다. 그래서 10만원 이하가 적절하다는 생각에서 벗어날 수 없었다. 그러면 내 생존의 문제는 어떻게 하지? \n\n# 아쉬운 과거의 나\n\n나는 ‘얼마에 이 서비스를 팔면 내가 지속해서 살아남을 수 있을까?’에 대한 답을 내 머리속에서 찾지 못했다. 세상의 문제를 능동적으로 풀고 싶다는 생각으로 회사를 나왔는데 그 전에 나의 생존이라는 문제를 풀지 못하고 있었다. 자연스레 이 서비스를 만들 동력을 잃어갔다. 결과적으로 나는 1년의 시간 동안 서비스를 만들지 못했다. 나는 그 때 너무 어렸던 것 같다. 돌아보면 나는 작고 핵심적인 기능만 담은 서비스를 일단 만들고 사람들의 피드백을 받으며 다음 스텝을 결정했어야 했다. 그러나 그때 내 생각의 중심에는 완벽한 걸 만들어서 시장에 들고가야 한다는 생각이 자리잡고 있었고 그로 인해 완벽하지 않다면 한 걸음도 나아가지 못하는 큰 실수를 저지르고 있었다. 뿐만 아니라 방위산업분야 외에는 통신 프로그램을 어떤 식으로 작성하고 있는지 경험이 없었다. 내가 아는 건 TCP, UDP 프로토콜 위에서 직접 애플리케이션 프로토콜을 주고받는 형식이었는데 지금 돌아보면 훨씬 큰 시장은 HTTP라는 프로토콜 위에서 동작하고 있었다. 시장에 대한 무지였다. \n\n# 다른 생존의 길을 찾다\n\n그래서 다른 생존의 길을 찾기 시작했다. 분명 서비스는 가치가 있는 것 같고 일단 만들어서 지속적으로 시장에 내 놓고 내가 알지 못하는 분야에도 나아가 보면 생각하지 못한 기회가 생길지 모른다고 생각하기 시작했다. 그래서 그렇게 싫어하던 외주 용역을 할 길이 없을지 찾아보기 시작했다. 그런데 외주 일자리 찾는 것도 쉽지 않았다. 이유는 특이한 내 기술스택 때문이었는데, 나는 당시에 C, C++ 기반 TCP, UDP 통신 프로그램 개발에 자신이 있었다. 그런데 외주 시장을 뒤져보니 대부분 웹이나 모바일 애플리케이션 개발 의뢰를 하고 있었고 내가 잘 할 수 있는 통신 프로그램을 개발하는 일은 보이지 않았다. 결국 다른 길을 찾아보다가 국가에서 지원하는 여러 창업 프로그램들이 있다는 걸 알게 되었다. 그 시기는 회사를 그만두고 9개월 가량이 지난 시점이었다. 경남에는 경남창조경제혁신 센터라는 곳이 있었는데 창업특공대라는 교육을 일정 주기로 개최하고 있어 교육에 참가하게 되었다. 정말 아차 싶었다. 회사를 그만두자 마자 이런 곳에 와서 교육을 받고 여러 창업자들과 교류하고 멘토링도 받고 했어야 한다고 느꼈다. 교육을 통해 창업아이템 발표를 하고 우수교육팀 3팀에 선정되어 30만원이라는 달콤한 수익도 얻었는데 그때는 이미 1년이라는 시간이 다 차갈 때 즈음이었다. 교육 이후에 창업지원센터에서 창원 지원금을 꽤 큰 돈으로 지원하고 있다는 것도 알게 되었고 이걸로 생존할 수 있겠다는 한 가닥 희망을 걸었지만 창업자의 월급으로는 사용할 수 없다는 제한이 있었다. 좌절이었다. 그때 즈음부터 다시 취직을 해야 할지 모른다는 생각이 들기 시작했고 슬슬 이력서를 다시 정리하기 시작했다. 아무것도 하지 않으면서 누가 갑자기 투자를 해주면 좋겠다는 상상도 하던 철없던 시절이기도 했다.\n\n![](https://velog.velcdn.com/images/joosing/post/cee5055f-5c6d-41f0-87cb-4d7d49d685b8/image.png)\n\n\n# 생존의 실패\n\n결국 모아두었던 돈으로는 1달을 버틸 수 있는 벼랑 끝에 선 시기가 왔다. 가장 쉽게 취직할 수 있는 길은 방산회사로 가는 것이었다. 이전 직장 선배의 추천 제안도 있었지만 방산회사로는 가고 싶지 않았다. 그래서 결국 우주산업 분야인 지금 회사로 오게 되었다. 창업을 위한 생존의 실패이자 새로운 기회의 창이 열렸다.\n\n# 상대방의 관점\n\n1년이라는 시간 아무 성과 없이 허무하게 지나갔다고 생각할 수도 있지만 그렇지는 않았다. 나는 그 당시 자주 시청하던 세바시라는 유튜브 채널에서 박신영님을 만나게 되었다. 그리고 그녀가 쓴 ‘기획의 정석’이라는 책을 만나게 되는데 이 책이 내 생각의 패러다임을 크게 바꾸어 놓았다. 일명 ‘글을 쓰든 말을 하든 상대방의 머리속에 그림을 그려주듯 하라’는 조언이었다. 다시 말해 누군가에게 무언가 전달해야 한다면 상대방의 입장에서 상대가 이해하고 받아들이기 쉽게 표현하라는 것이었다. 나는 이 말에 큰 감명을 받았고 내 삶의 여러 영역에 실천해 보기 시작했다. 그때 당시 나는 교회에서 초등학교 아이들 교사로 섬기고 있었는데 여기서 많은 것들을 기획해서 도전하고 시험해 보게 된 것 같다. 교회 학교에서는 아이들에게 메시지를 전달하기 위해 많은 노력을 하는데 그때 아이들 입장에서 어떻게 메시지를 전달하면 잘 와닿을지 고민을 많이 했다. 나는 아이들을 가르치는 교사가 아니라 서기라는 역할을 맡고 있었는데 여러 자료들을 만들고 행사 기획을 돕는 일들을 했다. 그때 내 생각의 몇몇 결과물들이 아이들에게 좋은 반응을 얻었던 것 같다. 그 중에서 교회에서 흔히 내는 십자말 성경퀴즈가 있는데 이걸 아이들의 관점에서 아이들이 즐겁게 능동적으로 참여할 수 없을지 고민하다가 ‘러닝퍼즐’이란 걸 기획했다. 아이들 관점에서 옛날 것으로 보이는 십자말퀴즈 종이를 게임 화면과 믹스해서 문제지를 만들고 그냥 문제를 푸는 것이 아니라 교회 전체 공간을 뛰어다니며 공간 안에서 답을 찾는 움직이는 십자말퀴즈였다. ‘러닝퍼즐’은 고리타분한 퀴즈를 귀찮아 하던 아이들 까지도 온통 교회를 뛰어다니게 만들었고, 중간중간 있는 성경책을 읽어야만 풀 수 있는 퀴즈도 엄청나게 집중하게 만드는 효과를 보았던 것 같다. 1년이라는 시간 ‘상대방의 관점’ 이라는 패러다임의 변화가 내 인생에 일어났다. 어떤 것을 만들더라도 상대방의 관점에 대해 생각하기 시작했다. 그 패러다임의 변화는 이후 지금까지도 내 삶에 큰 영향을 주고 있다. \n\n![](https://velog.velcdn.com/images/joosing/post/a5bc0d89-e859-470b-bd60-040dd47ddfbe/image.png)\n\n\n# 아련한 추억\n\n지금 회사에서 일하다 힘들고 답답한 일이 있으면 늘 2019년의 기회에 왜 더 잘 하지 못했을까 그때로 다시 돌아가면 더 잘할 수 있을 것 같다는 생각이 들곤 한다. 그래서 이상하게 이후에 그 도시를, 그 도서관 곁을 일부러 지나가게 되면 가슴이 먹먹해지고 아려온다.\n\n# 딤섬\n\n내게는 또다른 추억 하나가 있다. 오래전 장모님과 아내와 부산 신세계백화점 안에 있는 딤섬을 먹었던 기억이다. 태어나 처음 딤섬이란 걸 먹었는데 너무 맛있어서 다시 가야지 가야지 하면서 못 가고 있던 터였다. 올해는 마음을 먹고 장모님을 모시고 다시 그곳에 갔다.  음, 근데 내가 그렇게 맛있었다고 추억하고 다시 먹고 싶다고 기대했던 그 맛이 아니다. 음식이 바뀐 것 같지는 않다. 다만 이제 나는 그때 처럼 딤섬을 처음 먹어 본 것이 아니고 그때와 나는 다르기 때문이라는 생각이 들었다. 머리 속을 스쳐지나 간다. 진해에서의 2019년 추억도 이렇지 않을까? 그때와 나는 다르다. 그때로 돌아간다고 다시 그때처럼 아름다운 시간이 되지 않을 수도 있다. 지금 내 상황에 맞는 새로운 것을 찾고 추구해야겠다는 생각을 하게 된다. 이제 2019년의 추억은 아름다운 추억으로 접어두기로 한다.\n\n![](https://velog.velcdn.com/images/joosing/post/9e89c7a6-4995-4f04-98f9-2e13ea55b857/image.png)\n\n\n# 새로운 기회를 향한 이동\n\n회사와 창업 사이에서 방황하던 나는 2020년 우주 스타트업 컨텍이라는 회사를 만나 새롭게 둥지를 틀게 되었다. 물론 아름다운 도시 진해를 떠나 세련된 분위기가 물씬 풍기는 세종시로 이사도 오게 되었다. 이곳에서 전혀 새로운 프레임워크, 전혀 새로운 프로그래밍 언어를 사용해 전혀 새로운 시스템 소프트웨어를 개발하고 있다. 내가 만든 소프트웨어를 통해 커다란 지상국 안테나가 저 먼 곳 우주에 있는 인공위성을 따라가며 데이터를 받는 일을 한다. 나는 이곳에서 우주로부터 오는 데이터를 사람들이 활용할 수 있도록 돕는 일을 하고 있다. 그러고 보니 지금 나는 가치 있는 일을 능동적으로 하며 살고 있는 것 같다. 마음에 갈증이 있었던 곳에서 주저하며 머물러 있었다면 결코 만나지 못했을 오늘에 감사함을 느낀다. 나는 오늘도 새로운 기회를 향해 이동하고 있다. 언젠가 또 다른 기회가 내 앞에 나타난다면 이번에는 작게 제품을 만들고 사람들의 피드백을 받으며 개선해 나가는 일을 해볼 것이다. 생존에 대한 계획도 조금 더 현실적이고 구체적으로 세워 진짜 꿈을 이루어 갈 수 있는 준비를 할 것이다. 혹 누군가 나와 같이 막연히 회사를 그만두고 싶다 거나 창업을 꿈꾼다면 나누고 싶은 이야기다. 그래도 무작정 그만두어 보는 것도 나쁘진 않다. 나처럼 잊지 못 할 아름다운 추억을 선물로 받을지도 모르는 일이니까.\n\n![](https://velog.velcdn.com/images/joosing/post/7c634f05-6ab3-41e5-8e7a-51e014580cb8/image.png)",
      "short_description": "마산과 부산 사이에는 내가 잠시 머물렀던 진해 바닷가 마을이 있다. 명절에 내려와 이 마을을 지날 때면 왠지 모르게 마음이 아린다. 나는 2018년 12월에 창원에서 다니던 회사를 그만두었다. 이직을 위한 것이 아니라 그냥 좀 쉬고 싶었고 어렴풋하게 창업이란 것을 해보",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/joosing/post/c7651bb1-41c2-4758-a04e-a1d73afeed43/image.png",
      "comments_count": 0,
      "url_slug": "새로운-기회를-향한-이동-교보문고-리드잇-6호-기고글",
      "likes": 1,
      "liked": false,
      "user": {
        "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
        "username": "joosing",
        "profile": {
          "id": "db38b276-ea4e-458a-81db-4886bfb7baee",
          "display_name": "JooSing",
          "thumbnail": "https://velog.velcdn.com/images/joosing/profile/f0237be9-1add-432a-89ec-14bf7c0e937c/image.png",
          "short_bio": "Software Engineer + Product Manager",
          "profile_links": {
            "url": "",
            "email": "joosing711@gmail.com",
            "github": "Jsing",
            "twitter": "joosings"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "Joo's Work",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": {
        "id": "15eb11c0-52f0-457f-abb1-da2c0d24ac14",
        "name": "생각/회고/계획",
        "url_slug": "회고",
        "series_posts": [
          {
            "id": "472ef448-487c-40cc-a604-ab6c82ade805",
            "post": {
              "id": "a2774e5f-45ac-4b7f-9921-80739b3d3f6c",
              "title": "우주지상국을 만든 개발자의 7가지 일 (2022 회고)",
              "url_slug": "7-things-of-space-ground-station-delveopment-2022",
              "user": {
                "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
                "username": "joosing",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "569a9b47-2d05-4101-941c-b3d46da2e9f1",
            "post": {
              "id": "2f1205a6-689b-46dc-a3ce-7b109e2ec7b5",
              "title": "39년 회고 : 용감하기",
              "url_slug": "39-years-retrospective",
              "user": {
                "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
                "username": "joosing",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "44a31760-a1f5-44ca-a08f-498599b0ffcf",
            "post": {
              "id": "2723ae65-7e21-46c5-8c3b-9a6ed91658e6",
              "title": "크리스찬의 삶과 목표",
              "url_slug": "크리스찬-삶",
              "user": {
                "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
                "username": "joosing",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "389e31d4-2429-4a75-9e68-29d5c08746e4",
            "post": {
              "id": "e8494ddc-125d-47d9-81cb-881a42be97e2",
              "title": "새로운 기회를 향한 이동 (교보문고 리드잇 6호 기고글)",
              "url_slug": "새로운-기회를-향한-이동-교보문고-리드잇-6호-기고글",
              "user": {
                "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
                "username": "joosing",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "7ed25cac-be43-4fd9-971b-97d0e0d5e2f3",
            "post": {
              "id": "bd4fe14a-076d-4830-be92-00a6d4c7c6dd",
              "title": "주니어 개발자의 온보딩을 도운 경험",
              "url_slug": "experience-helped-on-boarding-of-junior-developer",
              "user": {
                "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
                "username": "joosing",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": {
          "id": "2723ae65-7e21-46c5-8c3b-9a6ed91658e6",
          "title": "크리스찬의 삶과 목표",
          "url_slug": "크리스찬-삶",
          "user": {
            "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
            "username": "joosing",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": {
          "id": "bd4fe14a-076d-4830-be92-00a6d4c7c6dd",
          "title": "주니어 개발자의 온보딩을 도운 경험",
          "url_slug": "experience-helped-on-boarding-of-junior-developer",
          "user": {
            "id": "646a1063-9b7d-49eb-a1bd-a45d4d678714",
            "username": "joosing",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "91d249ca-079c-4910-b1a5-b6422db6a93f",
      "title": "[번역] 객체 대신 Map을 더 사용해보기",
      "released_at": "2023-02-16T14:51:31.730Z",
      "updated_at": "2023-03-22T01:19:31.027Z",
      "tags": [
        "JavaScript",
        "Korean FE Article",
        "Map",
        "object",
        "번역"
      ],
      "body": "> 원문 : https://www.builder.io/blog/maps\n\n자바스크립트의 객체는 굉장합니다. 객체는 무엇이든 할 수 있습니다! 말 그대로 무엇이든 말이죠.\n\n하지만 모든 것들과 마찬가지로, 단지 무언가를 _할 수 있다고_ 해서 반드시 _해야 한다_는 의미는 아닙니다.\n\n```js\n// 🚩\nconst mapOfThings = {}\n\nmapOfThings[myThing.id] = myThing\n\ndelete mapOfThings[myThing.id]\n```\n\n예를 들어, 자바스크립트의 객체를 사용하여 자주 추가하거나 제거하는 키를 가지는 임의의 키-값 쌍을 저장하는 경우, 일반 객체 대신 `map`을 사용하는 것을 고려해야 합니다.\n\n```js\n// ✅\nconst mapOfThings = new Map()\n\nmapOfThings.set(myThing.id, myThing)\n\nmapOfThings.delete(myThing.id)\n```\n\n## 객체의 성능 문제\n\n객체에서 delete 연산자는 성능 저하로 악명이 높은 반면, map은 키를 제거하는 데 최적화되어 있으며 경우에 따라 훨씬 더 빠를 수 있습니다.\n\n![map vs object.webp](https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fdefb300b5ebe42108d9ab813d3b99b5f?format=webp&width=2000)\n\n물론 이는 하나의 [벤치마크 예시](https://perf.builder.io/?q=eyJpZCI6IndkbG1kbG94cm5nIiwidGl0bGUiOiJNYXAgdnMgT2JqZWN0IFBlcmZvcm1hbmNlIiwiYmVmb3JlIjoiY29uc3QgcmFuZG9tS2V5ID0gKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApXG5jb25zdCBkYXRhID0gWy4uLkFycmF5KDEwMDAwKV0ubWFwKHJhbmRvbUtleSlcbmNvbnN0IG9iaiA9IE9iamVjdC5mcm9tRW50cmllcyhkYXRhLm1hcCh4ID0%2BIFt4LCB4XSkpXG5jb25zdCBtYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG9iaikpIiwidGVzdHMiOlt7Im5hbWUiOiJNYXAiLCJjb2RlIjoiLy8gRnJlZXplIHRoZSBrZXlzIGxpc3QgKHdlIGRvbid0IHdhbnQgdG8gbXV0YXRlIHdoaWxlIGl0ZXJhdGluZylcbmNvbnN0IGtleXMgPSBBcnJheS5mcm9tKG1hcC5rZXlzKCkpXG5mb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gIC8vIERlbGV0ZSBrZXlcbiAgbWFwLmRlbGV0ZShrZXkpXG4gIC8vIENyZWF0ZSBhIHJhbmRvbSBuZXcga2V5XG4gIGNvbnN0IG5ld0tleSA9IHJhbmRvbUtleSgpXG4gIG1hcC5zZXQobmV3S2V5LCBuZXdLZXkpXG59IiwicnVucyI6W10sIm9wcyI6OTAxfSx7Im5hbWUiOiJPYmplY3QiLCJjb2RlIjoiY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbmZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgLy8gRGVsZXRlIGtleVxuICBkZWxldGUgb2JqW2tleV1cbiAgLy8gQ3JlYXRlIGEgcmFuZG9tIG5ldyBrZXlcbiAgY29uc3QgbmV3S2V5ID0gcmFuZG9tS2V5KClcbiAgb2JqW25ld0tleV0gPSBuZXdLZXlcbn0iLCJydW5zIjpbXSwib3BzIjoxODN9XSwidXBkYXRlZCI6IjIwMjMtMDItMDlUMDc6MDk6MzQuMjY2WiJ9)일 뿐입니다.(Core i7 MBP에서 Chorme v109로 실행) [Zhenghao He](https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza)가 만든 [또 다른 벤치마크](https://www.notion.so/Use-Maps-more-and-Objects-less-Outline-6f3e4c17e18543908ddde250ad9d2315)를 비교해 볼 수도 있습니다. 명심하세요. 이와 같은 마이크로 벤치마크는 [불완전하기로 악명 높으므로](https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html) 참고만 하는 것을 추천드립니다.\n\n즉, 저나 다른 사람의 벤치마크를 신뢰할 필요는 없습니다. [MDN은 map이 키를 자주 추가하거나 제거하는 사례에 특히 최적화되어 있다는 것을 명확하게 설명합니다.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#objects_vs._maps) 이러한 사례에 최적화되지 않은 객체와 비교하면 다음과 같습니다.\n\n![map vs object performance.webp](https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F0d08535f5d2e4c5bbefe257c58103d25?format=webp&width=2000)\n\n이유가 궁금하신가요? 이는 자바스크립트 VM이 [JS 객체의 형태](https://www.builder.io/blog/maps#performance-issues-with-objects)를 가정하여 최적화하는 방법과 관련이 있습니다. 반면 map은 키가 동적으로 끊임없이 변경되는 해시맵의 쓰임새를 위해 특별히 제작되었습니다.\n\nMiško([Builder.io](https://www.builder.io/)의 CTO, Angular 및 [Qwik](https://qwik.builder.io/) 작성자)의 스레드에서 VM이 형태를 취하는 방식에 대해 자세히 읽어보세요.\n\n!twitter[mhevery/status/1622499229813047296]\n\n자바스크립트에서 객체의 성능 특성과 키를 자주 추가하거나 제거하는 해시맵과 같은 사용 사례에 최적화되지 않은 이유를 설명하는 글인 [What's up with monomorphism](https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html)도 있는데 아주 좋습니다.\n\n그러나 성능 외에도 map은 객체에 존재하는 여러 문제를 해결합니다.\n\n## 내장된 키 문제\n\n해시맵과 유사한 사례에 대한 객체의 주요 문제 중 하나는 객체가 이미 내장된 수많은 키로 인해 오염되었다는 것입니다. _무슨 의미일까요?_\n\n```js\nconst myMap = {}\n\nmyMap.valueOf // => [Function: valueOf]\nmyMap.toString // => [Function: toString]\nmyMap.hasOwnProperty // => [Function: hasOwnProperty]\nmyMap.isPrototypeOf // => [Function: isPrototypeOf]\nmyMap.propertyIsEnumerable // => [Function: propertyIsEnumerable]\nmyMap.toLocaleString // => [Function: toLocaleString]\nmyMap.constructor // => [Function: Object]\n```\n\n따라서 비어있는 객체일지라도 이러한 프로퍼티 중 하나에 접근해보면 각 프로퍼티에는 이미 값이 존재합니다.\n\n이것만으로도 임의 키 해시맵에 객체를 사용하지 않는 명확한 이유가 됩니다. 나중에 발견하게 될지도 모르는 곤란한 버그로 이어질 수 있기 때문입니다.\n\n## 반복의 어색함\n\n자바스크립트 객체가 키를 처리하는 이상한 방식에 대해 말하자면, 객체를 반복하는 데 있어 문제가 아주 많습니다.\n\n예를 들어, 다음과 같이 하면 안 된다는 것을 이미 알고 있을 수 있습니다.\n\n```js\nfor (const key in myObject) {\n  // 🚩 의도하지 않은 일부 상속된 키를 우연히 발견할 수 있습니다.\n}\n```\n\n대신 이렇게 하라는 안내를 받았을 수도 있습니다.\n\n```js\nfor (const key in myObject) {\n  if (myObject.hasOwnProperty(key)) {\n    // 🚩\n  }\n}\n```\n\n하지만 `myObject.hasOwnProperty`는 다른 값으로 쉽게 재정의될 수 있으므로 여전히 문제가 있습니다. 다른 사용자가 `myObject.hasOwnProperty = () => explode().`를 수행하는 것을 막을 수는 없습니다.\n\n따라서 다음과 같은 짜증나는 작업을 대신 수행해야 합니다.\n\n```js\nfor (const key in myObject) {\n  if (Object.prototype.hasOwnProperty.call(myObject, key) {\n    // 😕\n  }\n}\n```\n\n또는 코드가 지저분해 보이지 않도록 원한다면 `for` 루프를 완전히 포기하고 `forEach`와 함께 `Object.keys`를 사용할 수 있습니다.\n\n```js\nObject.keys(myObject).forEach(key => {\n  // 😬\n})\n```\n\n그러나 map을 사용하면 이런 문제가 전혀 없습니다. 표준 이터레이터와 함께 표준 `for` 루프를 사용할 수 있으며 `key`와 `value`를 한번에 가져오기 위해 매우 멋진 구조 분해 패턴을 사용할 수 있습니다.\n\n```js\nfor (const [key, value] of myMap) {\n // 😍\n}\n```\n\n_좋네요._\n\n## 키 순서\n\nmap의 또 다른 장점은 키 순서를 유지한다는 것입니다. 이 기능은 오랫동안 요구되어 왔었는데, 이제 map에 존재합니다.\n\n또한 정확한 순서로 map에서 직접 키를 분해할 수 있다는 멋진 기능을 제공합니다.\n\n```js\nconst [[firstKey, firstValue]] = myMap\n```\n\n이를 통해 O(1) LRU 캐시 구현과 같은 몇 가지 흥미로운 사용 사례를 얻을 수도 있습니다.\n\n!twitter[Steve8708/status/1623906230841536515]\n\n## 복사\n\n객체에는 몇 가지 장점이 있습니다. 예를 들어, 객체를 펼치거나 할당하는 등 객체를 _복사하기가 매우 쉽다_는 점입니다.\n\n```js\nconst copied = {...myObject}\nconst copied = Object.assign({}, myObject)\n```\n\n하지만 map 또한 복사하기가 쉽습니다.\n\n```js\nconst copied = new Map(myMap)\n```\n\n위 코드가 작동하는 이유는 `Map`의 생성자가 `[key, value]` 튜플의 이터러블을 사용하기 때문입니다. 편리하게도 map은 이터러블하여 키와 값의 튜플을 생성합니다. 멋지네요.\n\n마찬가지로, [structuredClone](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)를 사용하여 객체와 마찬가지로 map의 깊은 복사본을 만들 수도 있습니다.\n\n```js\nconst deepCopy = structuredClone(myMap)\n```\n\n## map을 객체로, 객체를 map으로 변환\n\n[Object.fromEntries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)를 사용하여 map을 객체로 쉽게 변환할 수 있습니다.\n\n```js\nconst myObj = Object.fromEntries(myMap)\n```\n\n[Object.entries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)를 사용하여 객체를 map으로도 쉽게 변환할 수 있습니다.\n\n쉽네요!\n\n이제 이것을 알았으므로 더 이상 튜플을 사용하여 map을 구성할 필요가 없습니다.\n\n```js\nconst myMap = new Map([['key', 'value'], ['keyTwo', 'valueTwo']])\n```\n\n대신 객체처럼 구성할 수 있습니다. 제 눈에는 이 방식이 조금 더 좋아보입니다.\n\n```js\nconst myMap = new Map(Object.entries({\n  key: 'value',\n  keyTwo: 'valueTwo',\n}))\n```\n\n또는 편리하고 작은 헬퍼를 만들 수도 있습니다.\n\n```js\nconst makeMap = (obj) => new Map(Object.entries(obj))\n\nconst myMap = makeMap({ key: 'value' })\n```\n\n타입스크립트 코드로 작성하면 다음과 같습니다.\n\n```ts\nconst makeMap = <V = unknown>(obj: Record<string, V>) =>\n  new Map<string, V>(Object.entries(obj))\n\nconst myMap = makeMap({ key: 'value' })\n// => Map<string, string>\n```\n\n저는 이 방식을 좋아합니다.\n\n## 키 타입\n\nmap은 단지 자바스크립트에서 키 값의 map을 처리하는 인체 공학적이고 더 좋은 성능의 방법만은 아닙니다. 일반 객체로는 전혀 할 수 없는 작업도 할 수 있습니다.\n\n예를 들어, map은 문자열만 키로 갖는 것에 대한 제한이 없습니다. 모든 타입의 객체를 map의 키로 사용할 수 있습니다. 무엇이든 말이죠.\n\n```js\nmyMap.set({}, value)\nmyMap.set([], value)\nmyMap.set(document.body, value)\nmyMap.set(function() {}, value)\nmyMap.set(myDog, value)\n```\n\n왜일까요?\n\n이에 대한 한 가지 유용한 사용 사례는 객체를 직접 수정할 필요 없이 메타데이터를 객체와 연결하는 것입니다.\n\n```js\nconst metadata = new Map()\n\nmetadata.set(myDomNode, {\n  internalId: '...'\n})\n\nmetadata.get(myDomNode)\n// => { internalId: '...' }\n```\n\n예를 들어 임시 상태를 데이터베이스에서 읽고 쓰는 객체에 연결하려는 경우에 유용합니다. 객체 참조와 직접 연결된 임시 데이터를 위험 없이 얼마든지 추가할 수 있습니다.\n\n```js\nconst metadata = new Map()\n\nmetadata.set(myTodo, {\n  focused: true\n})\n\nmetadata.get(myTodo)\n// => { focused: true }\n```\n\n이제 `myToDo`를 데이터베이스에 다시 저장하면 저장하려는 값만 있고 별도의 map에 있는 임시 상태는 포함되지 않습니다.\n\n하지만 여기에는 한 가지 문제가 있습니다.\n\n일반적으로 가비지 컬렉터는 이 객체를 수집하고 메모리에서 제거합니다. 그러나 map이 참조를 보유하고 있기 때문에 가비지 수집이 되지 않아 메모리 누수가 발생합니다.\n\n## WeakMaps\n\n여기에서 `WeakMap`을 사용할 수 있습니다. Weak Map은 객체에 대한 약한 참조를 보유하므로 위의 메모리 누수를 완벽하게 해결합니다.\n\n따라서 다른 모든 참조가 제거되면 객체가 자동으로 가비지 수집되어 이 Weak Map에서 제거됩니다.\n\n```js\nconst metadata = new WeakMap()\n\n// ✅ 다른 참조가 없을 때 자동으로 myTodo가 map에서 제거되어 메모리 누수가 없습니다.\nmetadata.set(myTodo, {\n  focused: true\n})\n```\n\n## 더 많은 Map 메서드\n\n계속 진행하기 전에 map에 대해 알아야 할 몇 가지 유용한 사항은 다음과 같습니다.\n\n```js\nmap.clear() // map 전체를 제거하기\nmap.size // map의 사이즈를 가져오기\nmap.keys() // map의 모든 키에 대한 이터레이터\nmap.values() // map의 모든 값에 대한 이터레이터\n```\n\nmap이 좋은 메소드를 가지고 있다는 걸 아시겠죠. 넘어가볼까요?\n\n## Sets\n\nmap에 대해 이야기할 때는 사촌인 Set도 언급해야 합니다. 어떤 집합이 아이템을 가지고 있는 경우 Set를 통해 더 나은 성능으로 쉽게 추가, 제거 및 조회할 수 있는 _고유한_ 요소 목록을 만들 수 있습니다.\n\n```js\nconst set = new Set([1, 2, 3])\n\nset.add(3)\nset.delete(4)\nset.has(5)\n```\n\n경우에 따라 set은 배열을 사용했을 때보다 [훨씬 더 나은 성능을 제공](https://perf.builder.io/?q=eyJpZCI6IjZtaDFsdjJscm56IiwidGl0bGUiOiJBcnJheSB2cyBTZXQgcGVyZm9ybWFuY2UiLCJiZWZvcmUiOiJjb25zdCBsZW5ndGggPSAxMF8wMDBcbmNvbnN0IGFyciA9IFsuLi5BcnJheShsZW5ndGgpLmtleXMoKV0ubWFwKHggPT4gKHggKiAxNikudG9TdHJpbmcoMzYpKVxuY29uc3Qgc2V0ID0gbmV3IFNldChhcnIpIiwidGVzdHMiOlt7Im5hbWUiOiJBcnJheSIsImNvZGUiOiJjb25zdCByYW5kb21WYWx1ZSA9IChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpICogMTYpLnRvU3RyaW5nKDM2KVxuXG4vLyBGaW5kIHRoZSB2YWx1ZVxuYXJyLmluY2x1ZGVzKHJhbmRvbVZhbHVlKVxuXG4vLyBSZW1vdmUgdGhlIHZhbHVlXG5hcnIuc3BsaWNlKGFyci5pbmRleE9mKHJhbmRvbVZhbHVlKSwgMSlcblxuLy8gQWRkIGl0IGJhY2tcbmFyci5wdXNoKHJhbmRvbVZhbHVlKSIsInJ1bnMiOltdLCJvcHMiOjEwNDQwfSx7Im5hbWUiOiJTZXQiLCJjb2RlIjoiY29uc3QgcmFuZG9tVmFsdWUgPSAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKSAqIDE2KS50b1N0cmluZygzNilcblxuLy8gRmluZCB0aGUgdmFsdWVcbnNldC5oYXMocmFuZG9tVmFsdWUpXG5cbi8vIFJlbW92ZSB0aGUgdmFsdWVcbnNldC5kZWxldGUocmFuZG9tVmFsdWUpXG5cbi8vIEFkZCBpdCBiYWNrXG5zZXQuYWRkKHJhbmRvbVZhbHVlKSIsInJ1bnMiOltdLCJvcHMiOjc4MTMxNn1dLCJ1cGRhdGVkIjoiMjAyMy0wMi0wN1QxMDoxOTozMi4wNjVaIn0%3D)할 수 있습니다.\n\n![array vs set.webp](https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F7034341cab394484b2e80ea3829b1acb?format=webp&width=2000)\n\n_어쩌구 저쩌구 마이크로 벤치마크는 완벽하지 않습니다. 실제 조건에서 자신의 코드를 테스트하여 이익을 얻는지 확인하거나, [제 말을 그대로 받아들이지 마세요.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#performance)_\n\n마찬가지로, 자바스크립트에서 메모리 누수를 방지하는 `WeakSet` 클래스도 있습니다.\n\n```js\n// 여기에는 메모리 누수가 없습니다, 캡틴\nconst checkedTodos = new WeakSet([todo1, todo2, todo3])\n```\n\n## 직렬화\n\nmap과 set에 비해 일반 객체와 배열이 갖는 마지막 이점은 직렬화라고 할 수 있습니다.\n\n_당신은 당신이 저를 알고 있다고 생각했어요. 하지만 당신을 위한 답이 있어요,_\n\n네, 객체 및 map에 대한 `JSON.strigify()` / `JSON.parse()` 지원은 매우 편리합니다.\n\n하지만 JSON을 예쁘게 출력하려면 항상 `null`을 두 번째 인자로 추가해야 한다는 사실을 알고 계셨나요? 이 매개변수가 무엇을 하는지 아시나요?\n\n```js\nJSON.stringify(obj, null, 2)\n//                  ^^^^ 이것은 어떤 일을 할까요\n```\n\n결과적으로 이 매개변수는 우리에게 매우 도움이 될 수 있습니다. _대체자_라고 하며 사용자 정의 유형을 직렬화하는 방법을 정의할 수 있습니다.\n\n이를 사용하여 직렬화를 하기 위해 map과 set을 객체와 배열로 쉽게 변환할 수 있습니다.\n\n```js\nJSON.stringify(obj, (key, value) => {\n  // map을 일반 객체로 변환\n  if (value instanceof Map) {\n    return Object.fromEntries(value)\n  }\n  // set을 일반 배열로 변환\n  if (value instanceof Set) {\n    return Array.from(value)\n  }\n  return value\n})\n```\n\n> 자바스크립트 개발자가 직장을 그만 둔 이유는 무엇인가요? 그들은 _배열_을 얻지 못했기 때문(arrays == a raise)이에요. 하하, 좋아요.\n\n이제 이것을 재사용 가능한 기본 함수로 추상화하고 직렬화할 수 있습니다.\n\n```js\nconst test = { set: new Set([1, 2, 3]), map: new Map([[\"key\", \"value\"]]) }\n\nJSON.stringify(test, replacer)\n// => { set: [1, 2, 3], map: { key: value } }\n```\n\n다시 변환하기 위해 `JSON.parse`와 동일한 트릭을 사용할 수 있지만, _리바이버(reviver)_ 매개 변수를 사용하여 배열을 set으로 변환하고 객체를 map으로 다시 변환할 수 있습니다.\n\n```js\nJSON.parse(string, (key, value) => {\n  if (Array.isArray(value)) {\n    return new Set(value)\n  }\n  if (value && typeof value === 'object') {\n    return new Map(Object.entries(value))\n  }\n  return value\n})\n```\n\n또한 _대체자_와 _리바이버_는 모두 재귀적으로 동작하므로 JSON 트리의 _어느 곳_에서나 map과 set을 직렬화 및 역직렬화할 수 있습니다.\n\n그러나 위의 직렬화 구현에는 작은 문제가 하나 있습니다.\n\n현재 일반 객체나 배열을 구문 분석 시 map 또는 set와 구별하지 않으므로 JSON에서 일반 객체와 map을 혼합할 수 없습니다. 그렇지 않으면 다음과 같이 문제가 발생하게 됩니다.\n\n```js\nconst obj = { hello: 'world' }\nconst str = JSON.stringify(obj, replacer)\nconst parsed = JSON.parse(obj, reviver)\n// Map<string, string>\n```\n\n예를 들어, `__type`이라고 하는 특수 프로퍼티를 만들어 이 문제를 해결할 수 있습니다.  `__type`은 다음과 같이 일반 객체나 배열이 아닌 map 또는 set이어야 함을 나타냅니다.\n\n```js\nfunction replacer(key, value) {\n  if (value instanceof Map) {\n    return { __type: 'Map', value: Object.fromEntries(value) }\n  }\n  if (value instanceof Set) {\n    return { __type: 'Set', value: Array.from(value) }\n  }\n  return value\n}\n\nfunction reviver(key, value) {\n  if (value?.__type === 'Set') {\n    return new Set(value.value)\n  }\n  if (value?.__type === 'Map') {\n    return new Map(Object.entries(value.value))\n  }\n  return value\n}\n\nconst obj = { set: new Set([1, 2]), map: new Map([['key', 'value']]) }\nconst str = JSON.stringify(obj, replacer)\nconst newObj = JSON.parse(str, reviver)\n// { set: new Set([1, 2]), map: new Map([['key', 'value']]) }\n```\n\n이제 set 및 map에 대한 JSON 직렬화 및 역직렬화를 완벽하게 지원합니다. 근사하네요.\n\n## 언제 어떤 것을 사용해야 할까요\n\n모든 `event`에 제목과 날짜가 있어야 하는 경우와 같이 키 집합이 잘 정의되어 구조화된 객체의 경우, 일반적으로 객체를 원할 수 있습니다.\n\n```js\n// 구조화된 객체의 경우, 객체를 사용하세요.\nconst event = {\n  title: 'Builder.io Conf',\n  date: new Date()\n}\n```\n\n고정된 키 집합이 있을 때 빠른 읽기 및 쓰기에 매우 최적화되어 있습니다.\n\n키를 여러 개 가질 수 있고 키를 자주 추가 및 제거해야 할 경우, 더 나은 성능과 효율성 측면을 위해 `map`을 사용하는 것이 좋습니다.\n\n```js\n// 동적 해시맵의 경우, Map을 사용하세요.\nconst eventsMap = new Map()\neventsMap.set(event.id, event)\neventsMap.delete(event.id)\n```\n\n요소의 순서가 중요하고 의도적으로 중복을 허용하는 배열을 만들 때는 보통 일반 배열이 좋습니다.\n\n```js\n// 정렬된 목록이나 중복 항목이 필요할 수 있는 목록의 경우, 배열을 사용하세요.\nconst myArray = [1, 2, 3, 2, 1]\n```\n\n그러나 중복을 원하지 않고 항목의 순서가 중요하지 않다면 set을 사용하는 걸 고려하세요.\n\n```js\n// 정렬되지 않은 고유 목록의 경우 Set을 사용하세요.\nconst set = new Set([1, 2, 3])\n```",
      "short_description": "이 글에서는 자바스크립트의 객체 대신 Map을 활용하는 대안에 대해 소개하고 있습니다. ",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/surim014/post/a1e71fac-d48d-4185-b6a5-3ec96207ef21/image.webp",
      "comments_count": 1,
      "url_slug": "use-maps-more-and-objects-less",
      "likes": 46,
      "liked": false,
      "user": {
        "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
        "username": "surim014",
        "profile": {
          "id": "b31bceb0-bcb4-11e9-a31b-7331a7d2542d",
          "display_name": "Sonny",
          "thumbnail": "https://velog.velcdn.com/images/surim014/profile/9d3c15fd-a07b-481b-b1f1-687a6ea7a4d0/image.jpg",
          "short_bio": "FrontEnd Developer ",
          "profile_links": {
            "url": "https://bit.ly/surim",
            "email": "surim014@naver.com",
            "github": "sonsurim",
            "twitter": "",
            "facebook": ""
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "surim's develog",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [
        {
          "id": "65c0eca7-8459-44c0-b81a-f3fb73659812",
          "user": {
            "id": "f56d3890-bd2b-11e9-aca9-db530189c847",
            "username": "gomjellie",
            "profile": {
              "id": "f5fef140-bd2b-11e9-aca9-db530189c847",
              "thumbnail": "https://images.velog.io/images/gomjellie/profile/57e0185f-7b00-4475-a235-1aeee663ed3f/image-top-4eb6b8642f61c5c012136597a25a7b72c705d6c6479a7270f3fb23726fddf585 2.png",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "> 자바스크립트 개발자가 직장을 그만 둔 이유는 무엇인가요? 그들은 배열을 얻지 못했기 때문(arrays == a raise)이에요. 하하, 좋아요. \n\n번역하기 엄청 힘든 문장이네요. \n이해 못하신 분을 위해서 설명을 드리면,\n`I got a raise` = `나 연봉인상 되었어` 라는 뜻이라서 만들어진 말장난입니다.",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-02-17T05:09:00.278Z",
          "deleted": false,
          "__typename": "Comment"
        }
      ],
      "series": {
        "id": "351caf83-4d8c-4741-8233-9556a784301f",
        "name": "Article",
        "url_slug": "Article",
        "series_posts": [
          {
            "id": "86097cf5-f24e-4c04-81c2-e1ac41840d58",
            "post": {
              "id": "e3e5c1b0-f819-47f1-aa72-402f9cc44054",
              "title": "(번역) React는 컴포넌트를 언제 다시 리렌더링 할까요?",
              "url_slug": "react-rerender",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "964c7a6e-102b-4991-9230-2f522e125f58",
            "post": {
              "id": "b3569e19-f63a-4098-8fa4-91eba891bede",
              "title": "[번역] 타입스크립트 Typeof 연산자를 위한 5가지 유용한 트릭",
              "url_slug": "5-very-useful-tricks-for-thetypescript-typeof-operator",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "cb9edf42-6fc1-408e-99b6-fd263c38daa8",
            "post": {
              "id": "6da73119-f03e-4d01-b39a-5c7c61255a1f",
              "title": "[번역] 최신 npm 패키지를 만들기 위한 모범 사례",
              "url_slug": "Best-practice-for-creating-a-modern-npm-package",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "cd1a6938-399b-43a0-8fd2-bfe16652e853",
            "post": {
              "id": "385a4aef-8d15-482f-b4ec-ff4b044e8324",
              "title": "[번역] Sentry.io 및 React를 사용한 프런트엔드 모니터링",
              "url_slug": "frontend-monitoring-with-sentry-and-react",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "a0be75cf-8752-4d8e-901a-9504a55dbf29",
            "post": {
              "id": "bb3bc445-198d-4f2b-b64d-c1d81d53b750",
              "title": "[번역] 프런트엔드 단위 테스트 모범 사례",
              "url_slug": "frontend-unit-testing-best-practices",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "29cb4792-8be7-4611-b2d0-2ec872a287c3",
            "post": {
              "id": "2e8c4121-1557-4583-b324-d96998e91504",
              "title": "[번역] Next.js 작동 방식",
              "url_slug": "how-next.js-works",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "6a0e1a8e-fe5a-46fd-869f-74fd778e042d",
            "post": {
              "id": "8c5963ed-1ce5-49c7-a236-a862fac962d1",
              "title": "[번역] 당신이 (아마도) 몰랐던 20가지 Git 명령 🧙‍♂️",
              "url_slug": "20-git-commands-you-probably-didnt-know-about-git",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "3a3d0f69-542f-4bbc-bc55-fa455039513c",
            "post": {
              "id": "91d249ca-079c-4910-b1a5-b6422db6a93f",
              "title": "[번역] 객체 대신 Map을 더 사용해보기",
              "url_slug": "use-maps-more-and-objects-less",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "db533b17-de7f-43d9-80a0-b37a829e14e9",
            "post": {
              "id": "dc99df1c-5e93-4cb4-a125-cb0d7e7133c7",
              "title": "[번역] 자바스크립트 가비지 컬렉터 실험",
              "url_slug": "Experiments-with-the-JavaScript-Garbage-Collector",
              "user": {
                "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
                "username": "surim014",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": {
          "id": "8c5963ed-1ce5-49c7-a236-a862fac962d1",
          "title": "[번역] 당신이 (아마도) 몰랐던 20가지 Git 명령 🧙‍♂️",
          "url_slug": "20-git-commands-you-probably-didnt-know-about-git",
          "user": {
            "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
            "username": "surim014",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": {
          "id": "dc99df1c-5e93-4cb4-a125-cb0d7e7133c7",
          "title": "[번역] 자바스크립트 가비지 컬렉터 실험",
          "url_slug": "Experiments-with-the-JavaScript-Garbage-Collector",
          "user": {
            "id": "b2b321d0-bcb4-11e9-a31b-7331a7d2542d",
            "username": "surim014",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "ac72dd39-c6e6-4b30-8863-381c89b268c2",
      "title": "Relay 15 변경점 살펴보기",
      "released_at": "2023-03-13T16:35:07.667Z",
      "updated_at": "2023-03-21T10:33:23.015Z",
      "tags": [],
      "body": "Relay 15.0.0가 [릴리즈](https://github.com/facebook/relay/releases/tag/v15.0.0)되었다. 엄청나게 큰 변경점이 있다기보단 breaking change가 있어서 (아마도 TS를 사용하는 일반 유저들은 큰 차이를 느끼지 못할 듯한) 메이저 버젼이 올라간 것 같고, 아직 정리된 announcement가 없어 어떤 변경점들이 있는지 눈에 띄는 것만 간단히 살펴보고자 한다.\n\n### fragment argument syntax 지원 [커밋](https://github.com/facebook/relay/commit/b497aa36305621750c5d351bdf2be3d318f6e646)\n\t\n기존 Relay에서 `@arguments` [directive](https://relay.dev/docs/api-reference/graphql-and-directives/#arguments)로 표현하던 것이 표준으로 [제안](https://github.com/graphql/graphql-spec/pull/1010)된 것으로 보인다.\n\n```graphql\n\n# 이전 \nfragment TodoList_list on TodoList @argumentDefinitions(\n  count: {type: \"Int\", defaultValue: 10},\n  userID: {type: \"ID\"},\n) {\n  title\n  todoItems(userID: $userID, first: $count) {\n    ...TodoItem_item\n  }\n}\nquery TodoListQuery($userID: ID) {\n  ...TodoList_list @arguments(count: $count, userID: $userID)\n}\n```\n공식 예제의 위 코드가 현재 제안된 표준대로 변경된다면,\n\n```graphql\n# 예시\nfragment TodoList_list(\n  count: Int = 10,\n  userID: ID,\n) on TodoList {\n  title\n  todoItems(userID: $userID, first: $count) {\n    ...TodoItem_item\n  }\n}\nquery TodoListQuery($userID: ID) {\n  ...TodoList_list(count: $count, userID: $userID)\n}\n```\n\n위와 같이 사용할 수 있을 것으로 보인다.\n\nRelay 컴파일러에 AST가 실험적으로 구현됐긴 하나, 서버 구현 등도 지원을 해야 하기에 당장 사용은 어려울 것으로 보인다.\n\n업데이트: envelop [플러그인](https://github.com/n1ru4l/envelop/blob/main/packages/plugins/fragment-arguments/README.md) 등을 이용하면 사용이 가능하다고 한다. (thanks to 혜성님)\n\n### Relay Resolvers\n\nRelay Live Resolver 구현이 추가되었다고 하는데, Apollo의 local resolver와 비슷하면서 좀 더 강력한 기능인 것 같다. [구현](https://github.com/facebook/relay/tree/main/packages/relay-runtime/store/experimental-live-resolvers)과 (준)공식 [예제](https://github.com/alunyov/relay-resolvers-example)가 있으니 살펴보면 좋을 것 같다.\n\n### [VS Code Relay extension](https://marketplace.visualstudio.com/items?itemName=meta.relay) 관련 업데이트\n\nRelay 컴파일러가 변경이 되어야 LSP에 반영이 되기 때문에 함께 추가된 것으로 보인다.\n\n- field reference (Go to References) 기능 추가, deprecated field warning, 자동 완성 추가 등.\n- 사실 rescript-relay 위주로 쓰다보니 이 익스텐션을 써 본 적은 없어 어느정도 사용성의 강화가 되었는지는 확실히 모르겠다.\n\n### Flight(RSC) 관련 예제 코드 제거\n\n[커밋](https://github.com/facebook/relay/commit/689dcb170a7500f99cf9ee04e5be91ee0c4925cb)\n\n> As we look forward to the future of Flight (server components), we don't believe it will be as tightly integrated into GraphQL/Relay, but rather integrated closer to SSR.\n\n... 라고 한다.\n\n#### 마무리\n\n일단은 이정도인 것 같다! 작년 하반기의 커밋도 포함되어 있을 정도로 Relay가 그다지 자주 릴리즈를 하는 편이 아니기 때문에, 현재는 버그픽스 등 위주로 판올림이 되며 메인터넌스 위주로, 기능상의 큰 변화는 없는 상태라고 봐도 무방할 듯 하다.\n\n최근 Relay에 관련된 트윗들이 많이 올라오고 있는데, 위의 VS Code 익스텐션 관련 업데이트를 보면 문서 측면에서의 보강도 아주 조금...? 기대해볼 수 있을지도 모르겠다.",
      "short_description": "Relay 15.0.0가 릴리즈되었다. 엄청나게 큰 변경점이 있다기보단 breaking change가 있어서 (아마도 TS를 사용하는 일반 유저들은 큰 차이를 느끼지 못할 듯한) 메이저 버젼이 올라간 것 같고, 아직 정리된 announcement가 없어 어떤 변경점들이",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": null,
      "comments_count": 0,
      "url_slug": "Relay-15-변경점-살펴보기",
      "likes": 0,
      "liked": false,
      "user": {
        "id": "92dd63e0-101d-11ea-83e5-1b8e3a0cd548",
        "username": "jaeholee",
        "profile": {
          "id": "93472230-101d-11ea-83e5-1b8e3a0cd548",
          "display_name": "Jaeho Lee",
          "thumbnail": "https://images.velog.io/profiles/jaeholee/thumbnails/1574752979.621.jpeg",
          "short_bio": "개발자",
          "profile_links": {
            "url": "https://jaeholee.read.cv",
            "email": "",
            "github": "sairion",
            "twitter": "jaeholee_dev"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "jhl",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": null,
      "linked_posts": {
        "previous": {
          "id": "32314d6f-b334-47b9-8ce1-c887e0a4b551",
          "title": "더 푸릇푸릇해질 다음 여정을 향해 - 그린랩스 회고",
          "url_slug": "더-푸릇푸릇해질-다음-여정을-향해-그린랩스-회고",
          "user": {
            "id": "92dd63e0-101d-11ea-83e5-1b8e3a0cd548",
            "username": "jaeholee",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": null,
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "77b6a46b-7f0c-42a4-8fc2-2afb04ec4a19",
      "title": "(번역) tRPC와 리액트를 사용해 풀 스택 타입스크립트 앱 만들기",
      "released_at": "2023-03-19T17:27:29.792Z",
      "updated_at": "2023-03-22T02:14:06.208Z",
      "tags": [
        "React",
        "tRPC",
        "typescript"
      ],
      "body": "> 원문: [https://www.robinwieruch.de/react-trpc/](https://www.robinwieruch.de/react-trpc/)\n\ntRPC를 사용하면 개발자가 풀 스택 애플리케이션에서 타입스크립트로 완전한 타입 세이프 API를 만들 수 있습니다. 서버 애플리케이션이 타입 세이프 함수(예: user 만들기, 식별자별 user 가져오기, 모든 user 가져오기 등과 같은 CRUD 연산)가 포함된 타입 세이프 라우터를 생성하면 클라이언트 애플리케이션은 추론된 타입 세이프 라우터에서 이러한 함수를 직접 호출할 수 있습니다. 내부적으로는 클라이언트와 서버 간의 통신에 여전히 HTTP가 사용됩니다.\n\n[tRPC](https://trpc.io/)를 사용하려면 클라이언트와 서버에서 타입스크립트를 사용해야 합니다. 클라이언트는 서버에서 타입 세이프 라우터를 가져와야 하므로 두 애플리케이션이 환경을 공유하는 것이 합리적입니다(폴더부터 [Monorepo](https://www.robinwieruch.de/javascript-monorepos/)까지 어느 것이든 괜찮습니다.). 라우터가 클라이언트와 서버 사이의 접착제 역할을 하므로 스키마(예: [OpenAPI](https://www.openapis.org/)를 사용한 REST) 또는 코드 생성(예: [GraphQL 코드 생성기](https://the-guild.dev/graphql/codegen)를 사용한 GraphQL) 없이 완전히 타입이 정의된 API를 얻을 수 있습니다.\n\nGraphQL과 [REST](https://www.robinwieruch.de/node-express-server-rest-api/) 모두 타입 세이프 API를 생성할 수 있지만, 추가로 생성된 파일에 이러한 타입을 생성하려면 항상 중간 과정이 필요합니다. 예를 들어 GraphQL 코드 생성기는 새로운 타입 세이프 스키마 파일을 생성합니다. tRPC를 사용하면 간단하게 서버에서 코드를 실행해 클라이언트 애플리케이션을 위한 타입 세이프 함수를 얻을 수 있습니다.\n\nGraphQL이나 REST와 비교했을 때, tRPC는 (지금까지는) 주로 많은 서비스를 오케스트레이션 할 필요가 없는 소규모 프로젝트(예: GraphQL)에 주로 사용되거나 반드시 표준화된 RESTful 접근 방식으로 리소스에서 작업하지 않아도 되는 경우에 사용됩니다. 그러나 tRPC는 결국 REST 라우터나 GraphQL 리졸버에서 직접 사용할 수 있는 서버의 함수일 뿐이므로 언제든 tRPC에서 GraphQL/REST로 마이그레이션 할 수 있습니다.\n\n다음 튜토리얼은 서버에서 Node + Express를 사용하고 클라이언트에서 React를 사용하여 작은 규모의 CRUD 애플리케이션을 만드는 방법을 안내합니다. tRPC를 사용해 두 세계 사이의 통신을 구축할 것입니다. 표시된 폴더 구조는 다음 단계에서 부분적으로 생성되지만 루트 폴더를 만드는 것부터 시작할 수도 있습니다.\n\n```text\n- my-project/\n--- client/\n--- server/\n```\n\n## tRPC를 사용한 풀스택 Node 앱\n\n이 섹션에서는 Node, tRPC 및 Express를 사용하여 서버 애플리케이션을 만들겠습니다. 먼저 커맨드라인에서 프로젝트에 서버용 폴더를 새로 생성합니다.\n\n```bash\nmkdir server\n```\n\n그런 다음 조그마한 자바스크립트 프로젝트를 생성하고 이를 타입스크립트 프로젝트로 업그레이드합니다.\n\n> 이 튜토리얼은 3부로 이루어진 시리즈 중 3부입니다.\n>\n> 1부: [모던 자바스크립트 프로젝트를 셋업 하는 방법](https://www.robinwieruch.de/javascript-project-setup-tutorial/)\n> 2부: [Node.js와 타입스크립트 사용하기](https://www.robinwieruch.de/typescript-node/)\n\n타입스크립트 애플리케이션을 실행한 후에는 서버에 대한 실제 tRPC 구현부터 시작하여 최종적으로 클라이언트에 완전히 타입 세이프 한 API를 노출할 수 있습니다. 먼저 커맨드라인에서 tRPC 서버 패키지를 설치합니다.\n\n```bash\nnpm install @trpc/server\n```\n\n그다음, 타입 세이프 스키마 유효성 검사를 위해 [Zod](https://github.com/colinhacks/zod)도 설치합니다. 예를 들어, Zod를 사용하면 서버 API에 도달하는 사용자의 입력에 대한 유효성을 검사할 수 있습니다.\n\n```bash\nnpm install zod\n```\n\n여기서 구축 하려는 애플리케이션의 구조는 다음과 같습니다.\n\n```text\n- client/\n- server/\n--- src/\n----- index.ts\n----- context.ts\n----- router.ts\n----- trpc.ts\n----- user/\n------- router.ts\n------- types.ts\n------- db.ts\n```\n\n앞으로의 과정에서 위에서 본 모든 폴더/파일을 작성할 것입니다. 보시다시피 서버 애플리케이션에는 *user/*폴더가 있습니다. 여기서 user 도메인에 대한 모든 CRUD 작업(예: user 생성)을 구현할 것입니다. _src/user/types.ts_ 파일에서 User 타입 정의부터 시작하겠습니다. 먼저 각 user에는 `id`와 `name`만 있습니다.\n\n```ts\nexport type User = {\n  id: string;\n  name: string;\n};\n```\n\n둘째로, *src/user/db.ts*라는 의사(pseudo) 데이터베이스 파일을 두 명의 user로 채웁니다.\n\n```ts\nimport { User } from './types';\n\nexport const users: User[] = [\n  {\n    id: '0',\n    name: 'Robin Wieruch',\n  },\n  {\n    id: '1',\n    name: 'Neil Kammen',\n  },\n];\n```\n\n세 번째로, 이 튜토리얼의 핵심인 _src/user/router.ts_ 파일에서 tRPC를 사용하여 user 도메인에 대한 [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) API를 구현할 것입니다. 쿼리(읽기) 또는 뮤테이션(쓰기)을 사용하여 `getUsers`, `getUserById` 및 `createUser` 함수를 만들겠습니다. `updateUserById`와 `deleteUserById` 함수는 스스로 자유롭게 추가해 보세요.\n\n```ts\nimport { z } from 'zod';\n\nimport { router, publicProcedure } from '../trpc';\n\nimport { users } from './db';\nimport { User } from './types';\n\nexport const userRouter = router({\n  getUsers: publicProcedure.query(() => {\n    return users;\n  }),\n  getUserById: publicProcedure\n    .input((val: unknown) => {\n      if (typeof val === 'string') return val;\n      throw new Error(`Invalid input: ${typeof val}`);\n    })\n    .query((req) => {\n      const { input } = req;\n\n      const user = users.find((user) => user.id === input);\n\n      return user;\n    }),\n  createUser: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation((req) => {\n      const { input } = req;\n\n      const user: User = {\n        id: `${Math.random()}`,\n        name: input.name,\n      };\n\n      users.push(user);\n\n      return user;\n    }),\n});\n```\n\n마지막 파일은 최종적으로 클라이언트 애플리케이션에 모든 user 관련 기능을 노출하는 `userRouter`를 생성합니다. 이 도메인별 라우터는 나중에 애플리케이션의 모든 도메인별 라우터를 합치는 루트 라우터에서 사용됩니다.\n\n또한 앞서 생성한 `User` 타입 정의와 의사 데이터베이스를 사용하고 있습니다. `createUser` 함수와 체이닝 된 `input` 함수를 자세히 살펴보면, Zod가 어떻게 입력이 문자열 데이터 타입의 `name`인지 유효성을 검사하는 데 사용되는지 알 수 있습니다. Zod는 타입스크립트 프로젝트의 스키마 유효성 검사에 적합하지만, tRPC에서는 Zod 뿐 아니라 모든 유효성 검사 라이브러리(예: [Yup](https://github.com/jquense/yup))를 사용할 수 있습니다.\n\n다음으로, 실제 tRPC `router`와 이전 `userRouter`에서 이미 사용한 `publicProcedure`를 구현해야 합니다. 새 _*src/trpc.ts*_ 파일을 생성하고 다음 구현을 추가합니다.\n\n```ts\nimport { initTRPC, inferAsyncReturnType } from '@trpc/server';\n\nimport { createContext } from './context';\n\nexport type Context = inferAsyncReturnType<typeof createContext>;\n\nconst t = initTRPC.context<Context>().create();\n\nexport const middleware = t.middleware;\nexport const router = t.router;\n\n/**\n * Public procedures\n **/\nexport const publicProcedure = t.procedure;\n```\n\n기본적으로 타입 세이프 라우터와 제한이 없는 공개 프로시저의 기반을 만들었습니다. 이는 기본적인 tRPC 셋업의 일종입니다. 나중에 미들웨어(예: 인증된 사용자 확인)를 사용하여 _보호된 프로시저_(예: 인증)를 추가할 수 있는 곳이기도 합니다. 남은 것은 _src/context.ts_ 파일입니다.\n\n```ts\nimport * as trpcExpress from '@trpc/server/adapters/express';\n\nexport const createContext = ({\n  req,\n  res,\n}: trpcExpress.CreateExpressContextOptions) => {\n  return {};\n};\n```\n\n이것 또한 모든 API 호출에 사용되는 컨텍스트의 기본 토대입니다. 하지만 여기서는 이미 tRPC와 함께 [Express](https://expressjs.com/)를 사용하도록 지정했습니다. [Fastify](https://www.fastify.io/)와 같은 다른 어댑터도 사용할 수 있습니다. 아직 반환된 컨텍스트에 아무것도 전달하지 않았지만, 요청에서 유효한 세션 토큰이 있을 때 인증된 사용자를 추가할 수 있는 위치가 될 것입니다. 그러면 이전 파일의 미들웨어가 보호된 프로시저를 사용하기 위해 인증된 사용자를 확인할 수 있습니다.\n\n앞서 tRPC로 사용자별 라우터를 만들었습니다. 다음으로 모든 도메인별 라우터를 통합하는 새 _src/router.ts_ 파일에 루트 라우터를 생성합니다. 여기에 나중에 다른 도메인별 라우터를 추가할 수 있습니다:\n\n```ts\nimport { router } from './trpc';\nimport { userRouter } from './user/router';\n\nexport const appRouter = router({\n  user: userRouter,\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n마지막으로 실제 서버를 설정해야 합니다. 여기서는 이미 컨텍스트에 tRPC + Express 어댑터를 사용했기 때문에 Express를 사용하겠지만 [다른 옵션](https://trpc.io/docs/adapters)도 사용할 수 있습니다. 먼저 Express를 설치하겠습니다.\n\n```bash\nnpm install express cors\nnpm install @types/express @types/cors --save-dev\n```\n\n둘째로, 앞서 최상위의 _src/index.ts_ 파일에서 생성한 라우터 및 컨텍스트와 함께 사용합니다.\n\n```ts\nimport cors from 'cors';\nimport express from 'express';\nimport * as trpcExpress from '@trpc/server/adapters/express';\n\nimport { appRouter } from './router';\nimport { createContext } from './context';\n\nconst app = express();\n\napp.use(cors());\n\napp.use(\n  '/trpc',\n  trpcExpress.createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  })\n);\n\napp.listen(4000);\n\nexport type AppRouter = typeof appRouter;\n```\n\n구현은 독립 실행형 Express 서버와 크게 다르지 않습니다. 유일한 두 가지 차이점은 tRPC의 Express 인식 통합입니다. 또한 클라이언트 애플리케이션에서 최종적으로 사용할 `AppRouter` 타입을 내보냅니다. `AppRouter`는 라우터의 구현이 아니라 타입 정의일 뿐이라는 점에 유의하세요.\n\n`npm start`로 서버를 시작하고 오류가 표시되지 않는지 확인합니다. 다음으로 내보낸 `AppRouter` 타입 정의와 해당 타입에 입력된 함수(예: `createUser`)를 사용하는 클라이언트 애플리케이션을 계속 진행하겠습니다.\n\n## tRPC를 사용한 풀스택 리액트 앱\n\n부연 설명: 앞으로 리액트를 사용하는 프런트엔드 애플리케이션은 Next.js 대신 Vite를 사용할 것입니다. 왜냐하면 저는 일반적으로 **The Road to React**와 같은 제 책에서도 초보자를 위해 서버 측 라우팅보다 클라이언트 측 라우팅을 가르치기 때문입니다. 제 콘텐츠의 독자들에게는 React와 Node로 [프런트엔드 및 백엔드 개발의 기초](https://www.robinwieruch.de/web-applications/)를 배운 후에 이어서 볼 수 있는 완벽한 콘텐츠가 될 것입니다.\n\n먼저 [Vite](https://vitejs.dev/)를 사용해 타입스크립트 프런트엔드 애플리케이션으로 React를 만들어 보겠습니다. 커맨드라인에서 프로젝트의 폴더로 이동합니다. 커맨드라인에 다음 지침에 따라 _client/_ 폴더를 (_server/_ 폴더 옆에)생성합니다.\n\n```bash\nnpm create vite@latest client -- --template react-ts\n```\n\nVite는 리액트와 타입스크립트로 최소한의 프런트엔드 애플리케이션을 생성하는 작업을 처리합니다. 마지막 명령어를 입력하면 _client/_ 폴더에 폴더/파일 구조가 표시됩니다. 그런 다음 새 _client/_ 폴더로 이동하여 모든 종속성을 설치하고 애플리케이션을 시작합니다. 그러면 브라우저에서 기본으로 제공되는 웹 애플리케이션을 확인할 수 있을 것입니다.\n\n```bash\ncd client\nnpm install\nnpm start\n```\n\n여기서부터 이 리액트/타입스크립트 애플리케이션에 대한 tRPC 구체적인 구현을 시작하겠습니다. 이 구현을 위해 프런트엔드 프로젝트에 이 두 가지 종속성을 설치해야 합니다. tRPC 서버에 요청하는 데 도움이 되는 tRPC 클라이언트와 프런트엔드에서 직접 종속성으로 사용하지는 않지만 tRPC 클라이언트의 필수 피어 종속성인 tRPC 서버입니다.\n\n```bash\nnpm install @trpc/client @trpc/server\n```\n\n여기서 궁극적인 목표는 프런트엔드 및 백엔드 애플리케이션의 전체 스택에 걸쳐 타입스크립트를 사용하여 종단 간 타입 안정성을 만드는 것입니다. 따라서 이 마법이 일어나는 곳에 _src/trpc.ts_ 라는 파일을 만들겠습니다.\n\n```ts\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\n\nimport type { AppRouter } from '../../server/src/index';\n\nexport const trpc = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:4000/trpc',\n    }),\n  ],\n});\n```\n\n기본적으로 우리는 여기에서 tRPC 클라이언트를 인스턴스화하고 있습니다. 이는 서버 애플리케이션의 API에 대한 최소한의 URL을 사용합니다. 그러나 마법은 _server/_ 프로젝트에서 _client/_ 프로젝트로 임포트 된 `AppRouter` 유형에 있습니다. 그다음 `AppRouter` 타입을 클라이언트 측 tRPC 인스턴스를 생성하기 위한 [타입스크립트 제네릭](https://www.robinwieruch.de/typescript-generics/)으로 사용할 수 있습니다. 결과적으로 백엔드의 모든 타입을 프런트엔드에서 상속합니다. 즉, 타입스크립트로 종단 간 타입 안전성을 달성한 것입니다.\n\n이제 리액트 컴포넌트에서 앞에서 서술한 것을 증명해 보겠습니다. 다음 구현은 _src/App.tsx_ 파일이 이전 파일에서 tRPC 클라이언트 인스턴스를 어떻게 가져오는지 보여줍니다. 컴포넌트가 렌더링 될 때 서버에서 실제 user를 가져오는 [리액트의 useEffect 훅](https://www.robinwieruch.de/react-useeffect-hook/)에서 사용됩니다. 중요한 것은 trpc 클라이언트의 모든 것이 타입 세이프하므로 IDE(예: VSCode)에서 자동으로 완성될 수 있다는 것입니다(예: `user` 및 `getUserById`).\n\n```ts\nimport * as React from 'react';\n\nimport { trpc } from './trpc';\n\nconst App = () => {\n  const fetchUser = async () => {\n    const user = await trpc.user.getUserById.query('0');\n\n    console.log(user);\n  };\n\n  React.useEffect(() => {\n    fetchUser();\n  }, []);\n\n  return <></>;\n};\n\nexport default App;\n```\n\n브라우저를 열면 사용자가 서버측에 로그인하는 것을 볼 수 있습니다. 리액트 프래그먼트를 사용했기 때문에 아무것도 렌더링되지 않습니다. 로깅이 보이지 않고 대신 오류가 표시되는 경우 클라이언트 애플리케이션에서 사용할 수 없으므로 커맨드라인에서 _server/_ 프로젝트를 시작해야 합니다.\n\n## React Query를 사용한 TRPC\n\n캐싱, 리페칭, 실패 시 재시도 같은 강력한 기능을 제공하기 때문에 리액트에서 데이터를 페칭 할 때 [React Query](https://www.npmjs.com/package/react-query)는 필수적입니다. 하지만 React Query는 항상 우리가 제어 불가능한 로딩 상태로 시작됩니다. 다행히도 tRPC에는 다음에 설정할 React Query 통합 기능이 함께 제공됩니다. 먼저, React Query(RQ)와 이를 위한 tRPC의 React Query 통합 기능을 설치합니다.\n\n```bash\nnpm install @tanstack/react-query @trpc/react-query\n```\n\n다음으로 _src/trpc.ts_ 파일로 이동하여 새로운 tRPC to React Query 어댑터를 포함 시킵니다. 이 파일에서 두 tRPC 인스턴스를 모두 내보내는 것을 잊지 마세요.\n\n```ts\nimport { createTRPCReact, httpBatchLink } from '@trpc/react-query';\n\nimport type { AppRouter } from '../../server/src/index';\n\nexport const trpc = createTRPCReact<AppRouter>();\n\nexport const trpcClient = trpc.createClient({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:4000/trpc',\n    }),\n  ],\n});\n```\n\n_src/main.tsx_ 파일에서 React Query와 tRPC를 모두 전역적으로 제공합니다.\n\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport {\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query';\n\nimport { trpc, trpcClient } from './trpc';\nimport App from './App';\n\nconst queryClient = new QueryClient();\n\nReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n).render(\n  <trpc.Provider client={trpcClient} queryClient={queryClient}>\n    <QueryClientProvider client={queryClient}>\n      <App />\n    </QueryClientProvider>\n  </trpc.Provider>\n);\n```\n\n마지막으로 React Query와 함께 tRPC를 사용할 수 있습니다. tRPC 인스턴스에서 `user` 라우터에 액세스하고, 거기서 `getUserById` 프로시저에 액세스하고, 마지막으로 React Query의 `useQuery` 훅에 액세스할 수 있습니다. 반환된 결과는 네이티브 React Query와 동일하며 완전히 타입 정의되어 있습니다. IDE의 자동 완성 기능으로 `trpc`의 모든 프로퍼티와 데이터에 액세스할 수 있습니다.\n\n```tsx\nimport * as React from 'react';\n\nimport { trpc } from './trpc';\n\nconst App = () => {\n  const { data, isLoading } = trpc.user.getUserById.useQuery('0');\n\n  if (isLoading) return <div>Loading ...</div>;\n\n  return <div>{data?.name}</div>;\n};\n\nexport default App;\n```\n\n메서드를 `getUserById`에서 `getUsers`로 변경하면 즉시 타입 에러가 발생합니다.\n\n```tsx\nimport * as React from 'react';\n\nimport { trpc } from './trpc';\n\nconst App = () => {\n  const { data, isLoading } = trpc.user.getUsers.useQuery();\n\n  if (isLoading) return <span>Loading ...</span>;\n\n  return <div>{data?.name}</div>;\n  // Property 'name' ^ does not exist on type 'User[]'.\n};\n\nexport default App;\n```\n\n사용자 [목록](https://www.robinwieruch.de/react-list-component/)을 렌더링 하는 적절한 구현으로 이 문제를 해결할 수 있습니다.\n\n```tsx\nimport * as React from 'react';\n\nimport { trpc } from './trpc';\n\nconst App = () => {\n  const { data, isLoading } = trpc.user.getUsers.useQuery();\n\n  if (isLoading) return <span>Loading ...</span>;\n\n  return (\n    <div>\n      <ul>\n        {(data ?? []).map((user) => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n지금까지 `getUserById`와 `getUsers` 함수를 사용했습니다. 마지막으로 서버의 라우터에 정의한 `createUser` 함수를 사용해 UI에서 user를 생성하겠습니다. 사용자가 이름을 입력하고 요청을 전송할 수 있는 [폼을 리액트로](https://www.robinwieruch.de/react-form/) 구현하겠습니다. tRPC 인스턴스를 통해 user 도메인과 그것의 함수(여기서는 `getUsers`와 `createUser`), 그리고 React Query에 동일하며 완전히 타입 정의된 각각의 쿼리/뮤테이션 함수에 액세스 하는 방법을 다시 한번 살펴보겠습니다.\n\n```tsx\nimport * as React from 'react';\n\nimport { trpc } from './trpc';\n\nconst App = () => {\n  const [name, setName] = React.useState('');\n\n  const { data, isLoading, refetch } = trpc.user.getUsers.useQuery();\n\n  const mutation = trpc.user.createUser.useMutation({\n    onSuccess: () => refetch(),\n  });\n\n  const handleChange = (\n    event: React.ChangeEvent<HTMLInputElement>\n  ) => {\n    setName(event.target.value);\n  };\n\n  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    setName('');\n    mutation.mutate({ name });\n    event.preventDefault();\n  };\n\n  if (isLoading) return <span>Loading ...</span>;\n\n  return (\n    <div>\n      <ul>\n        {(data ?? []).map((user) => (\n          <li key={user.id}>{user.name}</li>\n        ))}\n      </ul>\n\n      <form onSubmit={handleSubmit}>\n        <label htmlFor=\"name\">Name:</label>\n        <input\n          id=\"name\"\n          type=\"text\"\n          value={name}\n          onChange={handleChange}\n        />\n\n        <button type=\"submit\">Create</button>\n      </form>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n이게 전부입니다. 서버와 클라이언트 애플리케이션을 tRPC로 구현했습니다. 서버는 Express를 사용하는 반면, 클라이언트는 리액트와 React Query를 사용합니다. 여기서는 몇 가지 타입 세이프 API 엔드포인트만 구현했지만, 더 많은 도메인별 라우터(예: Post, Comment)와 라우터 내 쿼리/뮤테이션 함수(예: `deleteUserById`)를 추가하면 어떻게 확장될지 상상할 수 있을 것입니다.\n\ntRPC는 클라이언트와 서버 모두에서 타입스크립트를 사용하고 코드 베이스를 공유하는 풀 스택 타입 세이프 애플리케이션을 위한 훌륭한 솔루션입니다. 기본 설정이 완료되고 나면 타입 세이프 API를 확장할 수 있는 놀라운 개발자 환경을 제공하기 때문에 새 프로젝트를 시작하는 데 매우 적합합니다. 나중에 필요한 경우에만 GraphQL 또는 REST로 마이그레이션 하여 그곳에서 함수를 재사용할 수 있습니다.\n\n>🚀 한국어로 된 프런트엔드 아티클을 빠르게 받아보고 싶다면 Korean FE Article([https://kofearticle.substack.com/](https://kofearticle.substack.com/))을 구독해주세요!",
      "short_description": "서버에서 Node + Express를 사용하고 클라이언트에서 React를 사용하여 작은 규모의 CRUD 애플리케이션을 만드는 방법을 안내합니다.",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/superlipbalm/post/95aa3594-4e51-4cc1-b31a-892ba736e588/image.jpeg",
      "comments_count": 0,
      "url_slug": "full-stack-typescript-with-trpc-and-react",
      "likes": 10,
      "liked": false,
      "user": {
        "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
        "username": "superlipbalm",
        "profile": {
          "id": "2da0851b-e111-4844-af5b-28560db1f1d3",
          "display_name": "Chanhee Kim",
          "thumbnail": "https://images.velog.io/images/superlipbalm/profile/ed4a5c63-6734-46c0-a976-e62749ca93cc/IMG_E1877.JPG",
          "short_bio": "FE 개발을 하고 있어요🌱",
          "profile_links": {
            "email": "superlipbalm@gmail.com",
            "github": "superLipbalm"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": "Chanhee Kim",
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": {
        "id": "7f832e98-741d-4a89-b1f9-1e49f12017c1",
        "name": "FE 글 번역",
        "url_slug": "FE-글-번역",
        "series_posts": [
          {
            "id": "8729e386-2629-4676-8e4b-fb9914dc2669",
            "post": {
              "id": "e57596c5-30a0-4356-afcb-3d4dc8b7da6f",
              "title": "(번역) 리액트 폼 성능 개선",
              "url_slug": "improve-the-performance-of-your-react-forms",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "bc107185-582c-4ff1-9854-6b9671e8859c",
            "post": {
              "id": "c61a364e-96a5-4d53-96db-558c3087b972",
              "title": "(번역) 자바스크립트 하이드레이션은 임시방편이지 해결책이 아닙니다 - by Miško Hevery",
              "url_slug": "javascript-hydration-is-a-workaround-not-a-solution",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "965494ca-82ea-47ba-bf33-b7dcb3e87b71",
            "post": {
              "id": "06ee896c-60e9-4fe2-b124-15367ec8c8c7",
              "title": "(번역) React Labs: 우리가 작업 중인것 – 2022년 6월",
              "url_slug": "React-Labs-What-Weve-Been-Working-On-June-2022",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "33a236a4-e562-4ea6-8008-b6bfaf50b58a",
            "post": {
              "id": "54831ace-1114-4e18-802f-2095e66cb5f0",
              "title": "(번역) 리액트 훅(React Hooks)의 클로저 트랩(Closure Trap) 이해하기",
              "url_slug": "the-closure-trap-of-react-hooks",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "f3a42bd9-e1ef-4cbe-910c-a81eb2a80250",
            "post": {
              "id": "c68889c1-1118-4c15-8636-aaaa8fbaa027",
              "title": "(번역) 자바스크립트 Import Map에 대해 알아야 할 모든 것",
              "url_slug": "everything-you-need-to-know-about-javascript-import-maps",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "72607a9d-9666-49bd-9778-fa95dd87ad55",
            "post": {
              "id": "0a61c054-528f-497d-889a-5f14341039fc",
              "title": "(번역) 반응형 사이트 생성기(Reactive Site Generator) Gatsby를 (다시) 소개합니다",
              "url_slug": "re-introducing-gatsby-a-reactive-site-generator",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "a4b45522-44db-4603-927b-6b479efd1c82",
            "post": {
              "id": "d97adf92-60b3-44be-ab22-60c22d8483bc",
              "title": "(번역) 자바스크립트의 역설",
              "url_slug": "the-javascript-paradox",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "87cd641d-223c-4872-8ba9-2ff6ddb0d38d",
            "post": {
              "id": "dbb74ed0-aa7e-4dcf-98d7-087d7ca6f62b",
              "title": "(번역) 블로그 답변: React 렌더링 동작에 대한 (거의) 완벽한 가이드",
              "url_slug": "blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "1382babf-d628-44c7-b192-7e61b1010d0f",
            "post": {
              "id": "2a2e06c4-e44f-47d6-b5bf-8d10286920e8",
              "title": "(번역) 리액트 상호 작용 시간 4배 향상하기",
              "url_slug": "improving-react-interaction-times-by-4x",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "b675d3a9-4641-4592-9ca4-84538069fb93",
            "post": {
              "id": "eb606f70-6c43-440e-9893-815ee1d78eab",
              "title": "(번역) 자바스크립트 생태계를 더 빠르게 - 라이브러리 하나씩",
              "url_slug": "speeding-up-javascript-ecosystem",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "14b1aaeb-7e1f-47a4-9156-c0080825f2b2",
            "post": {
              "id": "c637b0c7-054e-4707-80a9-bd93a03854d8",
              "title": "(번역) Concurrent 리액트에 대해 알아야 할 모든 것(그리고 Suspense에 대해서 약간)",
              "url_slug": "everything-you-need-to-know-about-concurrent-react",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "54eb2123-9206-40d9-bdd9-83a41a33d4bd",
            "post": {
              "id": "77b6a46b-7f0c-42a4-8fc2-2afb04ec4a19",
              "title": "(번역) tRPC와 리액트를 사용해 풀 스택 타입스크립트 앱 만들기",
              "url_slug": "full-stack-typescript-with-trpc-and-react",
              "user": {
                "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
                "username": "superlipbalm",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": {
          "id": "c637b0c7-054e-4707-80a9-bd93a03854d8",
          "title": "(번역) Concurrent 리액트에 대해 알아야 할 모든 것(그리고 Suspense에 대해서 약간)",
          "url_slug": "everything-you-need-to-know-about-concurrent-react",
          "user": {
            "id": "e773c0a7-c6e6-49da-8a06-b6d4dc3600f6",
            "username": "superlipbalm",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": null,
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "feee4bb8-871f-4673-9614-ba1974677aa1",
      "title": "🍿 자료구조 개념 정리 (1) 시간복잡도, 빅오 표기법, 배열, 연결리스트",
      "released_at": "2023-03-11T14:48:59.554Z",
      "updated_at": "2023-03-22T02:10:42.412Z",
      "tags": [],
      "body": "# 🧑🏻‍🏫 자료구조와 알고리즘\n\n> 그동안 몰랐었던 자료구조와 알고리즘에 대한 기본기를 알아보자\n\n## 🍿 개요\n\n프로그램은 자료구조와 알고리즘으로 이루어져있다.\n자료구조는 데이터가 어떤 구조로 저장되고 어떻게 사용되는지를 나타낸다.\n우리는 자료구조를 배우지 않았어도 프로그래밍을 하면서 사용했다.\n\n가장 **단순한 자료구조는 변수**다. 또 다른 자료구조는 **배열**이다.\n자료구조를 제대로 이용하면 코드를 좀 더 단순하게 짤 수 있다.\n\n## 🍿 알고리즘\n\n알고리즘은 어떤 문제를 해결하기 위한 구체적이고 확실한 방법을 말한다.\n\n#### 좋은 알고리즘이란 ? \n사용자에 따라 다르다. \n메모리를 적게 사용하고자 한다면 메모리를 적게 사용되는 알고리즘이 더 좋은 알고리즘이라고 할 수 있고, 어떤 사용자는 속도가 더 빠른 것을 원하는 사람도 있다.\n 하지만 일반적으로는 **알고리즘의 속도를 성능의 척도**로 사용한다.\n 이를 ⭐️`시간 복잡도`⭐️ 라고 부른다. \n \n## 🍿 시간 복잡도란 ?\n특정 알고리즘이 **어떤 문제를 해결하는 데 걸리는 시간**을 말한다. 하지만 시간을 측정해서 알고리즘을 평가하기에는 현실적으로는 어렵다. 왜냐면 사용자 컴퓨터의 성능이 다 다르기 때문이다. 그래서 실행 시간이 다 다르다. 누구는 5초가 걸릴 수가있고 누구는 1초 걸릴 수가 있다.\n\n그러므로 코드 성능에 많은 영향을 주는 부분을 찾아 실행시간을 예측한다.\n**코드에서 성능에 많은 영향을 주는 것은?** 바로 ⭐️**반복문**⭐️이다.\n반복문이 여러 번 반복될수록 실행시간이 길어진다. 그래서 알고리즘의 성능을 평가할 때는 알고리즘의 반복문을 보고 평가한다.\n\n원하는 데이터를 찾는 알고리즘은 경우를 나누어서 평가한다.\n>\n- 최선의 경우 한 번에 찾을 때 -> **Big-오메가**\n- 최악의 경우 배열의 길이만큼 걸릴 때 -> **Big-O**\n- 평균의 경우 배열의 길이 중간만큼 걸릴 때 -> **Big-세타**\n\n이중에서 우리가 가장 많이 사용하는 것은 **Big-O** 이다.\n빅오표기법은 O(n)으로 표기한다. 데이터가 많아지면 그에 비례해서 계산량이 많아지는 것이다.\nO(n)의 알고리즘은 선형시간 알고리즘이라고 한다.\n빅 오 표기법은 입력이 늘어날 때, 계산량이 늘어나는 척도를 나타내기 위한 것이다.\n\n선형시간 알고리즘 외에도 상수시간 알고리즘이라는 것도 있다.\n이것은 O(1)으로 표현한다. 입력의 크기와 상관없이 상수의 시간이 걸린다는 의미이다.\n이 외에도 성능은** O(logn), O(nlogn), O(n^2), O(2n), O(n!)-> 팩토리얼** 등등이 있다. ~~_(아.. 진심 머리 아파옴..🤦🏻‍♀️)_~~\n\n\n### 빅오 표기법의 특징\n 만약 `n^2(제곱) + 2n + 100`의 성능을 보이는 알고리즘이 있다면 이를 표현할 때는?\n **계산에 가장 많은 영향을 미치는 항만 표기하는 것**이다.\n n^2이 가장 많은 영향을 미치므로 이거 외에 나머지 항들은 버려진다.\n \n `3n^2 +100n` 은 가장 큰 항을 포기하는 것이다. 그리고 상수는 필요없기 때문에 상수도 버려준다. 그럼 답은 **O(n^2)**이 된다.\n \n \n### JS 실행 환경 구축\n\n확장자 mjs 파일은 자바스크립트 모듈 파일이다. (테스트코드 작성할 때 쓴다)\n\n \n ## 🍿 배열\n \n배열은 프로그래밍에서 **기본적으로 제공해주는 자료구조**이다. \n배열을 선언했다면 운영체제는 메모리에서 숫자가 들어갈 수 있는 빈 공간을 찾아서 순서대로 값들을 할당해줍니다. 할당하지 않은 부분은 의미없는 쓰레기 값이 저장된다. \n\n그리고 운영체제는 **배열의 시작 주소만 기억**합니다. 프로그래머가 배열의 세번째 원소에 접근하고 싶다면 `arr[2]` 이런식으로 접근한다. 운영체제는 이런 메모리 공간들을 다 기억하기 때문에 길이 상관없이 한 번에 가져온다. **배열은 읽기/쓰기 등 참조에서 좋은 성능**을 보여준다.\n\n배열의 성능은 좋지만 데이터의 삽입, 삭제 성능은 그리 좋지 않다.\n자바스크립트 배열은 상황에 따라서 연속적, 불연속적으로 메모리를 할당하지만 대부분은 불연속적으로 할당한다.\n\n### 배열의 장점\n- 읽기, 쓰기와 같은 참조에는 O(1)의 성능을 가진다.\n\n### 배열의 단점\n- 크기 예측이 힘들기 때문에 메모리 낭비가 발생할 수 있다.\n- 데이터 삽입, 삭제가 비효율적이다.\n\n## 🍿 연결리스트\n배열의 단점을 해결하기 위해서, 저장하려는 데이터들을 메모리 공간에 분산 할당하고 이 데이터들을 서로 연결해준다. 이것은 **노드라는 것을 만들어서 수행**한다. 노드의 구조는 데이터를 담는 변수 하나와 다음 노드를 가리키는 변수 하나를 말한다.\n\n필요한 노드를 만들어 연결하는데 이런 구조로 `연결 리스트`라고 부른다.\n\n### 연결리스트의 장점\n\n빈 메모리공간 아무 곳에 데이터를 생성하고 연결만 해주면 되기 때문에 배열에서 초기 크기를 알아야 하는 단점이 연결리스트에는 없다.\n배열은 1과 3사이에 2를 삽입하려면 3뒤로의 데이터들은 모두 뒤로 밀려나기 때문에 **오버헤드가** 많이 드는 반면, **연결리스트는** 중간에 데이터를 삽입하면 다음 가리키는 노드만 바꿔주면 되기 때문에 아주 간단하게 작업할 수 있다. 데이터 삭제도 마찬가지다.\n\n### 연결리스트의 단점\n- 연결리스트는 데이터들이 전부 떨어져 있기 때문에 바로 접근할 수 없습니다.\n- 연결리스트에서의 데이터 참조는 O(n)의 성능을 가진다. 배열은 O(1)의 성능을 가져서 더 좋음.\n\n\n\n\n### 결론\n\n성능을 생각하면 배열이고, 메모리 절약을 위해서는 연결리스트를 선택해서 코딩하면 된다.\n \n \n \n \n \n",
      "short_description": "자료구조와 알고리즘\n\n> 기업 코테 대비를 위해 자료구조와 알고리즘에 대한 기본기를 알아보자\n\n개요\n\n프로그램은 자료구조와 알고리즘으로 이루어져있다.\n자료구조는 데이터가 어떤 구조로 저장되고 어떻게 사용되는지를 나타낸다.\n우리는 자료구조를 배우지 않았어도 프로그래밍을 ",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/leemember/post/8028ff9b-6fdd-4375-930e-62c742d8c25d/image.gif",
      "comments_count": 3,
      "url_slug": "코테-대비-자료구조와-알고리즘",
      "likes": 39,
      "liked": false,
      "user": {
        "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
        "username": "leemember",
        "profile": {
          "id": "a6d193d8-e94f-471c-9bd5-2a4025b54103",
          "display_name": "leehyunju",
          "thumbnail": "https://images.velog.io/images/leemember/profile/c8ee5d39-820e-4fab-909d-4cd8d695609f/social.jpeg",
          "short_bio": "아늑한 뇌공간  🧠",
          "profile_links": {
            "email": "hyunmail521@gmail.com",
            "github": "leemember"
          },
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": null,
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [
        {
          "id": "5ff0cfef-8e87-4563-b7ac-6600cf80b769",
          "user": {
            "id": "51d0c628-f470-47d7-8e62-fdb1b3bb136c",
            "username": "reagan987",
            "profile": {
              "id": "68793532-b97a-4375-b3f1-b18b167e916a",
              "thumbnail": null,
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "자료구조에서 중요한 개념인 시간복잡도와 빅오 표기법, 배열, 그리고 연결리스트를 정리해보면 다음과 같습니다. 시간복잡도는 알고리즘의 수행 시간을 나타내며, 빅오 표기법은 알고리즘의 시간복잡도를 간단하게 나타내는 표기법입니다. 배열은 고정된 크기의 데이터를 순차적으로 저장하는 자료구조이며, 연결리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성된 자료구조입니다.   <a href=\"https://www.alaskasworld.kim/\">Alaska Employee PET Login</a>",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-16T11:18:44.020Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "d7f09156-2741-4f0c-919d-0dec57ecaeee",
          "user": {
            "id": "dda0ddaf-d659-47ab-8835-167e49b74e91",
            "username": "peratingrower",
            "profile": {
              "id": "457d2f9d-4b12-4d08-9f1a-1d7f3f6814ce",
              "thumbnail": "https://velog.velcdn.com/images/peratingrower/profile/f01e7158-a952-469e-82cb-63783a96cfcc/image.jpg",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "문제가 있지만 이 시나리오에서는 \"범인\"을 식별할 수 없습니다. 이전에는 이러한 애플리케이션 간의 통합이 완벽하게 작동했습니다.\n",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-17T02:22:59.907Z",
          "deleted": false,
          "__typename": "Comment"
        },
        {
          "id": "e6c81c8b-6071-47c3-922c-7a2981ee9fa4",
          "user": {
            "id": "dda0ddaf-d659-47ab-8835-167e49b74e91",
            "username": "peratingrower",
            "profile": {
              "id": "457d2f9d-4b12-4d08-9f1a-1d7f3f6814ce",
              "thumbnail": "https://velog.velcdn.com/images/peratingrower/profile/f01e7158-a952-469e-82cb-63783a96cfcc/image.jpg",
              "__typename": "UserProfile"
            },
            "__typename": "User"
          },
          "text": "문제가 있지만 이 시나리오에서는 \"범인\"을 식별할 수 없습니다. 이전에는 이러한 애플리케이션 간의 통합이 완벽하게 작동했습니다.\n<a href=\"https://spacebarclicker.co\">spacebar clicker</a>\n",
          "replies_count": 0,
          "level": 0,
          "created_at": "2023-03-17T02:22:59.926Z",
          "deleted": false,
          "__typename": "Comment"
        }
      ],
      "series": {
        "id": "9a2f5bd0-a55a-49e0-a373-e92545d41d53",
        "name": "자료구조와 알고리즘 개념 익히기",
        "url_slug": "자료구조와-알고리즘-개념-익히기",
        "series_posts": [
          {
            "id": "d7c8b990-5a47-4674-9c39-f8400166ffc2",
            "post": {
              "id": "feee4bb8-871f-4673-9614-ba1974677aa1",
              "title": "🍿 자료구조 개념 정리 (1) 시간복잡도, 빅오 표기법, 배열, 연결리스트",
              "url_slug": "코테-대비-자료구조와-알고리즘",
              "user": {
                "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
                "username": "leemember",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          },
          {
            "id": "449d0c15-bf46-469a-806f-2450d831fa09",
            "post": {
              "id": "11f33433-c74f-48f1-bcc2-784911d5c626",
              "title": "🍿 자료구조 개념 정리 (2) 스택, 큐, 덱, 해시테이블, 셋",
              "url_slug": "자료구조-개념-정리-2-스택-큐-덱-해시테이블-셋",
              "user": {
                "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
                "username": "leemember",
                "__typename": "User"
              },
              "__typename": "Post"
            },
            "__typename": "SeriesPost"
          }
        ],
        "__typename": "Series"
      },
      "linked_posts": {
        "previous": null,
        "next": {
          "id": "11f33433-c74f-48f1-bcc2-784911d5c626",
          "title": "🍿 자료구조 개념 정리 (2) 스택, 큐, 덱, 해시테이블, 셋",
          "url_slug": "자료구조-개념-정리-2-스택-큐-덱-해시테이블-셋",
          "user": {
            "id": "866e4ce9-41f1-4718-9f94-87e007be7d7b",
            "username": "leemember",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    },
    {
      "id": "e9a4f9e8-4af1-406b-acbd-403e84ccf5fb",
      "title": "[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 3월 3주차",
      "released_at": "2023-03-20T01:35:32.940Z",
      "updated_at": "2023-03-22T02:07:37.431Z",
      "tags": [],
      "body": "동료들은 다 아는 정보, 나만 모르지 않게 만들어주는\n[일일일](https://oneoneone.kr/)에서 한 주간 개발자들이 많이 읽은 상위 10개의 아티클들을 소개합니다.\n\n✅ 실시간으로 나와 비슷한 동료들이 많이 읽은 아티클을 보고 싶다면? (잡담 없이 링크 공유만!)\n✅ '일일일 - 개발' 오픈채팅방 링크 : https://open.kakao.com/o/gTgUKcAe (참여 코드 : oneone1)\n✅ '일일일 - ChatGPT' 오픈채팅방 링크 : https://open.kakao.com/o/gZeCQ08e (참여 코드 : oneone1)\n\n![](https://velog.velcdn.com/images/oneoneone/post/2b8c8042-16fb-4fc5-b10b-3a78772899b2/image.png)\n\n---\n## 01. 드디어 OpenAI GPT-4가 발표되었습니다\n\n✅ 우리는 딥 러닝을 확장하기 위한 OpenAI의 노력의 결과물인 GPT-4를 만들었습니다. GPT-4는 많은 실제 시나리오에서 인간보다 능력이 떨어지지만 다양한 전문적 및 학문적 벤치마크에서 인간 수준의 성능을 보여주는 대규모 복합 모델(이미지 및 텍스트 입력 수용, 텍스트 출력 방출)입니다.\nhttps://oneoneone.kr/content/54aeafa7\n\n---\n## 02. 25년 차고요, 제 직업은 개발자를 키우는 개발자입니다 | 오늘의집 CTO\n\n✅ 오늘 영상의 주인공은 오늘의집 엔지니어링 리드 저스틴입니다. 삼성전자와 구글을 거쳐 오늘의집에 오기까지, 저스틴의 25년 동안의 개발자 여정을 영상으로 만나보세요.\nhttps://oneoneone.kr/content/7727f569\n\n---\n## 03. 🚀 12년 차 개발자의 감정 관리법\n\n✅ 하루에 최소 몇 시간씩 몇 년 동안 무언가에 집중할 수 있다면https://oneoneone.kr/content/d2ff4720\n\n---\n## 04. 코드 재사용성을 결정하기 전 고려해야 할 것들\n\n✅ 프로젝트를 진행하다 보면 특정 코드를 재사용하는 것에 대해 논의할 때가 많다. 그런데 항상 명확한 결론을 내지 못하고 끝낸 적이 많다. 왜 그럴까? 코드 재사용에 대한 의사결정은 간단해 보이지만 사실 많은 고민이 필요한 일이기 때문이다.\nhttps://oneoneone.kr/content/8ad2fdba\n\n---\n## 05. DataGrip 에서 안전하게 Command 수행하기\n\n✅ DataGrip을 포함한 GUI 도구로 운영 DB에 쿼리를 수행하는건 항상 조심해야한다. 하지만, 매번 모든 쿼리를 사람이 주의해서 수행하는건 불가능하며, 사람이라면 무조건 실수를 할 수 있다.\nhttps://oneoneone.kr/content/dcc28345\n\n---\n## 06. 유용한 ChatGPT 크롬 확장 프로그램 9가지\n\n✅ ChatGPT는 날이 갈수록 인기를 얻고 있으며, 이 서비스를 통해 거의 모든 것을 검색할 수 있기 때문에 당연한 결과라고 볼 수 있다. 크롬(Chrome) 사용자라면 브라우저에서 바로 ChatGPT 기능을 제공하는 확장 프로그램이 많다는 사실에 놀랄 수 있다.\nhttps://oneoneone.kr/content/cfd5799c\n\n---\n## 07. (해외) 웹 개발자를 위한 5가지 필수 Google 크롬 확장 프로그램\n\n✅ 이 기사에서는 구글 크롬 브라우저를 통해 웹 개발을 더 효율적으로 할 수 있는 5가지 필수 확장 프로그램에 대해 설명하고 있다.\nhttps://oneoneone.kr/content/c1fefbf4\n\n---\n## 08. 🧑🏻‍🏫 프론트엔드 기술 면접 단골 개념들 정리 (리액트 / 상태관리 라이브러리 / 환경셋팅 편)\n\n✅ 리액트는 자바스크립트와 XML을 이용하여 UI 코드를 작성하며, 컴포넌트를 사용하여 화면 요소를 재사용하고 부모-자식 관계를 이용한 데이터 전달 및 상태 관리가 가능하다. 제어 컴포넌트와 비제어 컴포넌트, 가상 DOM과 diffing 알고리즘, Hooks 등을 활용하여 효율적인 웹 어플리케이션을 구현할 수 있다.\nhttps://oneoneone.kr/content/ca09c5b0\n\n---\n## 09. (해외) Javascript 개발자라면 별표 표시할 10개의 리포지토리\n\n✅ 만약 Javascript 개발자이고 오픈 소스 기여자인 경우, 이곳에서는 사용하거나 기여할 수 있는 활발한 프로젝트가 있습니다. 이에는 Storybook, ToolJet, Supabase, Gatsby, Cypress, D3js, Anime, AdonisJs 등이 포함됩니다. 각 프로젝트는 고유한 특징과 기술 스택을 갖추고 있지만, 모두 Javascript 개발을 보다 쉽고 효율적으로 만들기 위해 초점을 맞춘 것입니다. 자료에는 문서, 튜토리얼 및 다른 개발자들과 연결할 수 있는 온라인 커뮤니티가 포함됩니다.\nhttps://oneoneone.kr/content/9c15c488\n\n---\n## 10. 노션을 대체하는 문서 협업 소프트웨어들\n\n✅ 이메일 뉴스레터에서는 노션을 대체하는 문서 협업 소프트웨어인 Coda, Almanac, Roam Research, Mem, 그리고 Dynalist를 소개하고 있다. 각각의 툴은 노션에 비해 확장된 기능이나 원격 협업에 특화된 기능, 네트워크 링크 형태의 노트 관리 기능 등을 제공하며, 다양한 사용자들의 요구에 대응하고 있다.\nhttps://oneoneone.kr/content/1ebcc6fa\n\n\n\n---\n![](https://velog.velcdn.com/images/oneoneone/post/0d0af2a7-78fc-436b-a57d-7ae49cf7b468/image.gif)\n\n## 🙋‍♂️ 앗, 나가시기 전에 잠시만요!\n\n지금 일일일에 로그인하시면 매일 나와 비슷한 동료들이 보고있는 추천 콘텐츠들을 받아볼 수 있어요.\n\n아래 초대 링크를 통해 회원가입하시면 추첨을 통해 스타벅스 쿠폰을 보내드리는 이벤트를 진행하고 있으니 많은 참여 부탁드려요!\n\n✅ 초대 링크 : https://oneoneone.kr/gift?refferal_code=57fb5e04\n✅ 일일일 바로가기 링크 : https://oneoneone.kr/",
      "short_description": "동료들은 다 아는 정보, 나만 모르지 않게 만들어주는일일일에서 한 주간 개발자들이 많이 읽은 상위 10개의 아티클들을 소개합니다.",
      "is_markdown": true,
      "is_private": false,
      "is_temp": false,
      "thumbnail": "https://velog.velcdn.com/images/oneoneone/post/2b8c8042-16fb-4fc5-b10b-3a78772899b2/image.png",
      "comments_count": 0,
      "url_slug": "mxtrxads",
      "likes": 7,
      "liked": false,
      "user": {
        "id": "86463af8-b496-4edc-8ea9-ecd209d3c094",
        "username": "oneoneone",
        "profile": {
          "id": "8f18006d-a879-4d96-a2a4-d126c303dc4f",
          "display_name": "ONEONEONE",
          "thumbnail": "https://velog.velcdn.com/images/oneoneone/profile/d7b4332e-760e-43c9-b4ca-a88832690ab5/social_profile.png",
          "short_bio": "관심 업계의 최신 트렌드를 가장 쉽고 빠르게 받아보는 방법",
          "profile_links": {},
          "__typename": "UserProfile"
        },
        "velog_config": {
          "title": null,
          "__typename": "VelogConfig"
        },
        "__typename": "User"
      },
      "comments": [],
      "series": null,
      "linked_posts": {
        "previous": {
          "id": "f412c5bc-bb16-4f10-8691-95f6625ca987",
          "title": "[TOP 10] 개발자들이 많이 읽은 아티클 모음 - 3월 2주차",
          "url_slug": "TOP-10-개발자들이-많이-읽은-아티클-모음-3월-2주차",
          "user": {
            "id": "86463af8-b496-4edc-8ea9-ecd209d3c094",
            "username": "oneoneone",
            "__typename": "User"
          },
          "__typename": "Post"
        },
        "next": null,
        "__typename": "LinkedPosts"
      },
      "__typename": "Post"
    }
  ]
}